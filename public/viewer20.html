<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TFLite Model Inspector</title>
    
    <style>
        * { box-sizing: border-box; }
        body { 
            font-family: system-ui, -apple-system, sans-serif; 
            background: #f5f5f5; 
            padding: 20px;
            margin: 0;
            line-height: 1.5;
        }
        .container { max-width: 900px; margin: 0 auto; }
        
        .card { 
            background: white; 
            padding: 24px; 
            border-radius: 8px; 
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            margin-bottom: 24px;
        }
        
        .status { 
            padding: 12px; 
            border-radius: 6px; 
            margin-bottom: 16px; 
            border-left: 4px solid;
        }
        .status-info { background: #e3f2fd; border-color: #2196f3; color: #1565c0; }
        .status-loaded { background: #e8f5e9; border-color: #4caf50; color: #2e7d32; }
        .status-error { background: #ffebee; border-color: #f44336; color: #c62828; }
        .status-warning { background: #fff3e0; border-color: #ff9800; color: #e65100; }

        input[type="text"], input[type="file"] { 
            width: 100%; 
            padding: 10px; 
            border: 1px solid #ddd; 
            border-radius: 4px; 
            margin-bottom: 12px;
            font-size: 14px;
        }
        
        button { 
            width: 100%; 
            padding: 12px; 
            border: none;
            border-radius: 4px; 
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
        }
        .btn-primary { background: #7c3aed; color: white; }
        .btn-primary:hover { background: #6d28d9; }
        .btn-secondary { background: #2563eb; color: white; margin-top: 20px; }
        .btn-secondary:hover { background: #1d4ed8; }
        button:disabled { background: #ccc; cursor: not-allowed; }

        h1 { 
            font-size: 28px; 
            font-weight: 700; 
            text-align: center; 
            color: #1f2937; 
            margin: 0 0 8px 0; 
        }
        h2 { 
            font-size: 20px; 
            font-weight: 600; 
            color: #6d28d9; 
            margin: 0 0 16px 0;
        }
        h3 { 
            font-size: 16px; 
            font-weight: 600; 
            color: #374151; 
            margin: 20px 0 8px 0;
        }
        
        label { 
            display: block; 
            font-size: 13px; 
            font-weight: 500; 
            color: #4b5563; 
            margin-bottom: 6px; 
        }
        
        .subtitle { 
            font-size: 14px; 
            color: #6b7280; 
            text-align: center; 
            margin-bottom: 24px; 
        }

        .code-block { 
            background: #f3f4f6; 
            padding: 12px; 
            border-radius: 4px; 
            font-family: monospace; 
            font-size: 13px;
            overflow-x: auto;
            margin-top: 8px;
        }

        .divider { 
            text-align: center; 
            margin: 12px 0; 
            font-style: italic;
            color: #9ca3af;
        }
        
        hr { 
            border: none; 
            border-top: 1px solid #e5e7eb; 
            margin: 24px 0; 
        }

        ul { 
            list-style: none; 
            padding: 0; 
            margin: 0; 
        }
        li { 
            padding: 8px 0; 
            border-bottom: 1px solid #f3f4f6; 
        }
        li:last-child { border-bottom: none; }

        .hidden { display: none; }
    </style>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite@0.0.1-alpha.9/dist/tf-tflite.min.js"></script>
</head>
<body>
    <div class="container">
        <h1>TFLite Model Inspector</h1>
        <p class="subtitle">Load a .tflite file and inspect its structure and output</p>

        <!-- Section 1: Load Model -->
        <div class="card">
            <h2>1. Load Model</h2>
            <div id="model-status" class="status status-info">Awaiting model file or URL...</div>

            <label for="model-file">Load from Local File (.tflite)</label>
            <input type="file" id="model-file" accept=".tflite,.lite">

            <p class="divider">— OR —</p>

            <label for="model-url">Load from URL</label>
            <input type="text" id="model-url" placeholder="https://example.com/model.tflite">
            
            <button onclick="loadModel()" id="load-button" class="btn-primary">
                Load and Inspect Model
            </button>
        </div>

        <!-- Section 2: Inspection -->
        <div id="inspection-section" class="card hidden">
            <h2>2. Model Signature</h2>
            
            <div id="input-summary" class="status status-info">Input: N/A</div>
            <div id="output-summary" class="status status-info">Output: N/A</div>
            
            <hr>
            
            <h3>Topology</h3>
            <div id="layer-count-summary" class="status status-info">Operations: N/A</div>
            <div class="code-block">
                <ul id="layer-details-list">
                    <li>Waiting for model...</li>
                </ul>
            </div>
            <p style="font-size: 12px; color: #9ca3af; margin-top: 8px;">
                Note: Layer extraction uses non-public API properties
            </p>

            <hr>

            <h3>Test Inference</h3>
            <label for="input-shape">Input Shape (auto-detected)</label>
            <input type="text" id="input-shape" placeholder="Will auto-populate from model">
            
            <button onclick="runInference()" id="run-button" class="btn-secondary" disabled>
                Run Test Inference
            </button>
        </div>

        <!-- Section 3: Results -->
        <div id="output-section" class="card hidden">
            <h2>3. Inference Results</h2>
            <div id="inference-status" class="status status-info">Run inference to see results</div>
            
            <div id="output-shape-result" class="code-block">Output Shape: N/A</div>
            <div id="output-data-preview" class="code-block">Data Preview: N/A</div>
            
            <hr>
            
            <h3>Performance Profiling</h3>
            <div id="profiling-summary" class="code-block">Run inference to see profiling data</div>
            
            <h3>Detailed Operation Timing (Top 10 Slowest)</h3>
            <div id="profiling-details" class="code-block">Run inference to see detailed timing</div>
        </div>

        <!-- Section 4: Complete Model Data -->
        <div id="model-data-section" class="card hidden">
            <h2>4. Complete Model Data (No Weights)</h2>
            <p style="font-size: 14px; color: #6b7280; margin-bottom: 16px;">
                All extractable model metadata and structure information
            </p>
            
            <h3>Model Metadata</h3>
            <div id="model-metadata" class="code-block">N/A</div>
            
            <h3>Quantization Info</h3>
            <div id="quantization-info" class="code-block">N/A</div>
            
            <h3>All Tensors (Intermediate)</h3>
            <div id="tensor-info" class="code-block">N/A</div>
            
            <h3>Operator Statistics</h3>
            <div id="operator-stats" class="code-block">N/A</div>
            
            <h3>Memory Analysis</h3>
            <div id="memory-analysis" class="code-block">N/A</div>
            
            <h3>Raw Model Structure (JSON)</h3>
            <div id="raw-structure" class="code-block" style="max-height: 400px; overflow-y: auto;">N/A</div>
        </div>
    </div>

    <script>
        let tfliteModel = null;
        const statusEl = document.getElementById('model-status');
        const loadBtn = document.getElementById('load-button');
        const runBtn = document.getElementById('run-button');
        const inspectionSection = document.getElementById('inspection-section');
        const outputSection = document.getElementById('output-section');
        const modelFileEl = document.getElementById('model-file'); 
        const modelUrlEl = document.getElementById('model-url'); 
        const inputShapeEl = document.getElementById('input-shape');
        const inputSummaryEl = document.getElementById('input-summary');
        const outputSummaryEl = document.getElementById('output-summary');
        const outputShapeResultEl = document.getElementById('output-shape-result');
        const outputDataPreviewEl = document.getElementById('output-data-preview');
        const inferenceStatusEl = document.getElementById('inference-status');
        const layerCountSummaryEl = document.getElementById('layer-count-summary');
        const layerDetailsListEl = document.getElementById('layer-details-list');
        const modelDataSection = document.getElementById('model-data-section');
        const modelMetadataEl = document.getElementById('model-metadata');
        const quantizationInfoEl = document.getElementById('quantization-info');
        const tensorInfoEl = document.getElementById('tensor-info');
        const operatorStatsEl = document.getElementById('operator-stats');
        const memoryAnalysisEl = document.getElementById('memory-analysis');
        const rawStructureEl = document.getElementById('raw-structure');
        const profilingSummaryEl = document.getElementById('profiling-summary');
        const profilingDetailsEl = document.getElementById('profiling-details');
        const extensionWarningEl = document.getElementById('extension-warning');

        function updateStatus(message, type = 'info') {
            statusEl.textContent = message;
            statusEl.className = `status status-${type}`;
            console.log(`[${type.toUpperCase()}] ${message}`);
        }

        function resetView() {
            tfliteModel = null;
            inspectionSection.classList.add('hidden');
            outputSection.classList.add('hidden');
            modelDataSection.classList.add('hidden');
            extensionWarningEl.classList.add('hidden');
            inputSummaryEl.textContent = 'Input: N/A';
            outputSummaryEl.textContent = 'Output: N/A';
            layerCountSummaryEl.textContent = 'Operations: N/A';
            layerDetailsListEl.innerHTML = '<li>Waiting for model...</li>';
            outputShapeResultEl.textContent = 'Output Shape: N/A';
            outputDataPreviewEl.textContent = 'Data Preview: N/A';
            inferenceStatusEl.textContent = 'Run inference to see results';
            inputShapeEl.value = '';
            runBtn.disabled = true;
            modelMetadataEl.textContent = 'N/A';
            quantizationInfoEl.textContent = 'N/A';
            tensorInfoEl.textContent = 'N/A';
            operatorStatsEl.textContent = 'N/A';
            memoryAnalysisEl.textContent = 'N/A';
            rawStructureEl.textContent = 'N/A';
            profilingSummaryEl.textContent = 'Run inference to see profiling data';
            profilingDetailsEl.textContent = 'Run inference to see detailed timing';
        }

        function readFileAsArrayBuffer(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.onerror = reject;
                reader.readAsArrayBuffer(file);
            });
        }
        
        function getLayerDetails(model) {
            let layerInfo = [];
            let layerCount = 0;

            try {
                const tfliteExecutor = model.executor && model.executor.tflite; 
                const graph = tfliteExecutor && tfliteExecutor.graph;
                
                if (graph && graph.nodes) {
                    for (const nodeName in graph.nodes) {
                        const node = graph.nodes[nodeName];
                        layerInfo.push({ name: nodeName, op: node.op });
                        layerCount++;
                    }
                } else {
                    layerInfo = [{ op: "WARNING", name: "Graph structure not found" }];
                }
            } catch (e) {
                console.error("Error parsing model structure:", e);
                layerInfo = [{ op: "ERROR", name: e.message }];
            }

            return { count: layerCount, layers: layerInfo };
        }

        function extractCompleteModelData(model) {
            const data = {
                metadata: {},
                quantization: {},
                tensors: [],
                operators: {},
                memory: {},
                rawStructure: {}
            };

            try {
                // Basic model info
                data.metadata.modelFormat = 'TensorFlow Lite';
                data.metadata.inputCount = model.inputs ? model.inputs.length : 0;
                data.metadata.outputCount = model.outputs ? model.outputs.length : 0;

                // Inputs detail
                if (model.inputs) {
                    data.metadata.inputs = model.inputs.map(inp => ({
                        name: inp.name,
                        shape: inp.shape,
                        dtype: inp.dtype
                    }));
                }

                // Outputs detail
                if (model.outputs) {
                    data.metadata.outputs = model.outputs.map(out => ({
                        name: out.name,
                        shape: out.shape,
                        dtype: out.dtype
                    }));
                }

                // Try to access internal structure
                const executor = model.executor;
                if (executor) {
                    const tfliteBackend = executor.tflite;
                    const graph = tfliteBackend?.graph;

                    if (graph) {
                        // Extract all tensors
                        if (graph.tensors) {
                            for (const tensorName in graph.tensors) {
                                const tensor = graph.tensors[tensorName];
                                data.tensors.push({
                                    name: tensorName,
                                    shape: tensor.shape || 'unknown',
                                    dtype: tensor.dtype || 'unknown',
                                    // Don't include actual data, just metadata
                                    size: tensor.shape ? tensor.shape.reduce((a, b) => a * b, 1) : 0
                                });
                            }
                        }

                        // Extract operators and count them
                        if (graph.nodes) {
                            const opCounts = {};
                            for (const nodeName in graph.nodes) {
                                const node = graph.nodes[nodeName];
                                const opType = node.op || 'Unknown';
                                opCounts[opType] = (opCounts[opType] || 0) + 1;
                                
                                // Store operator details (without weights)
                                if (!data.operators[opType]) {
                                    data.operators[opType] = {
                                        count: 0,
                                        examples: []
                                    };
                                }
                                data.operators[opType].count++;
                                if (data.operators[opType].examples.length < 3) {
                                    data.operators[opType].examples.push({
                                        name: nodeName,
                                        inputs: node.inputs || [],
                                        outputs: node.outputs || []
                                    });
                                }
                            }
                        }

                        // Quantization info from inputs/outputs
                        data.quantization.inputQuantization = model.inputs?.map(inp => ({
                            name: inp.name,
                            dtype: inp.dtype,
                            quantized: inp.dtype.includes('int') || inp.dtype.includes('uint')
                        })) || [];

                        data.quantization.outputQuantization = model.outputs?.map(out => ({
                            name: out.name,
                            dtype: out.dtype,
                            quantized: out.dtype.includes('int') || out.dtype.includes('uint')
                        })) || [];

                        // Memory analysis
                        let totalElements = 0;
                        let totalBytes = 0;
                        const dtypeBreakdown = {};
                        
                        data.tensors.forEach(tensor => {
                            const elements = tensor.size;
                            totalElements += elements;
                            
                            // Count by dtype
                            dtypeBreakdown[tensor.dtype] = (dtypeBreakdown[tensor.dtype] || 0) + 1;
                            
                            // Estimate bytes (4 for float32, 1 for int8, etc)
                            let bytesPerElement = 4;
                            if (tensor.dtype.includes('int8') || tensor.dtype.includes('uint8')) bytesPerElement = 1;
                            else if (tensor.dtype.includes('int16') || tensor.dtype.includes('float16')) bytesPerElement = 2;
                            else if (tensor.dtype.includes('int64')) bytesPerElement = 8;
                            totalBytes += elements * bytesPerElement;
                        });

                        data.memory = {
                            totalTensorElements: totalElements,
                            estimatedMemoryBytes: totalBytes,
                            estimatedMemoryKB: (totalBytes / 1024).toFixed(2),
                            estimatedMemoryMB: (totalBytes / (1024 * 1024)).toFixed(4),
                            tensorCount: data.tensors.length,
                            dtypeBreakdown: dtypeBreakdown,
                            largestTensors: data.tensors
                                .sort((a, b) => b.size - a.size)
                                .slice(0, 5)
                                .map(t => ({
                                    name: t.name,
                                    shape: t.shape,
                                    elements: t.size,
                                    dtype: t.dtype
                                }))
                        };

                        // Raw structure (sanitized - no weight data)
                        const nodesList = graph.nodes ? Object.keys(graph.nodes) : [];
                        const tensorsList = graph.tensors ? Object.keys(graph.tensors) : [];
                        
                        data.rawStructure = {
                            graphNodes: nodesList.length,
                            graphTensors: tensorsList.length,
                            sampleNodes: nodesList.slice(0, 5),
                            sampleTensors: tensorsList.slice(0, 5),
                            executor: {
                                type: executor.constructor?.name || 'unknown',
                                hasGraph: !!graph,
                                hasTfliteBackend: !!tfliteBackend
                            },
                            modelSignature: {
                                inputs: model.inputs?.length || 0,
                                outputs: model.outputs?.length || 0
                            }
                        };
                    }
                }

            } catch (e) {
                console.error("Error extracting complete model data:", e);
                data.error = e.message;
            }

            return data;
        }

        function displayCompleteModelData(data) {
            // Model Metadata
            modelMetadataEl.textContent = JSON.stringify(data.metadata, null, 2);

            // Quantization Info
            const quantInfo = {
                inputQuantization: data.quantization.inputQuantization,
                outputQuantization: data.quantization.outputQuantization,
                summary: {
                    hasQuantizedInputs: data.quantization.inputQuantization?.some(q => q.quantized) || false,
                    hasQuantizedOutputs: data.quantization.outputQuantization?.some(q => q.quantized) || false
                }
            };
            quantizationInfoEl.textContent = JSON.stringify(quantInfo, null, 2);

            // Tensor Info (first 20 tensors)
            const tensorSummary = {
                totalTensors: data.tensors.length,
                sample: data.tensors.slice(0, 20),
                note: data.tensors.length > 20 ? `Showing first 20 of ${data.tensors.length} tensors` : 'All tensors shown'
            };
            tensorInfoEl.textContent = JSON.stringify(tensorSummary, null, 2);

            // Operator Statistics
            const opStats = {
                totalOperatorTypes: Object.keys(data.operators).length,
                operators: data.operators
            };
            operatorStatsEl.textContent = JSON.stringify(opStats, null, 2);

            // Memory Analysis
            memoryAnalysisEl.textContent = JSON.stringify(data.memory, null, 2);

            // Raw Structure
            rawStructureEl.textContent = JSON.stringify(data.rawStructure, null, 2);
        }

        async function loadModel() {
            cleanupOldModel(); // Clean up previous model if exists
            resetView();
            loadBtn.disabled = true;

            const selectedFile = modelFileEl.files[0];
            const url = modelUrlEl.value.trim();
            let modelSource = null;

            if (selectedFile) {
                updateStatus(`Reading file: ${selectedFile.name}...`, 'info');
                
                // Check file extension and show warning if .lite instead of .tflite
                const fileName = selectedFile.name.toLowerCase();
                if (fileName.endsWith('.lite')) {
                    console.warn('File has .lite extension. Standard extension is .tflite');
                    extensionWarningEl.classList.remove('hidden');
                } else {
                    extensionWarningEl.classList.add('hidden');
                }
                
                try {
                    modelSource = await readFileAsArrayBuffer(selectedFile);
                    modelUrlEl.value = ''; 
                } catch (error) {
                    updateStatus(`File read error: ${error.message}`, 'error');
                    loadBtn.disabled = false;
                    return;
                }
            } else if (url) {
                updateStatus(`Loading from URL: ${url}...`, 'info');
                modelSource = url;
                modelFileEl.value = ''; 
            } else {
                updateStatus('Please select a file or enter a URL', 'error');
                loadBtn.disabled = false;
                return;
            }

            try {
                if (typeof tflite.setWasmPath === 'function') {
                    tflite.setWasmPath('https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite@0.0.1-alpha.9/dist/');
                }

                // Load model with profiling enabled
                tfliteModel = await tflite.loadTFLiteModel(modelSource, {
                    enableProfiling: true,
                    numThreads: navigator.hardwareConcurrency || 4
                });
                updateStatus('Model loaded successfully', 'loaded');
                loadBtn.disabled = false;
                
                console.log("Model inputs:", tfliteModel.inputs);
                console.log("Model outputs:", tfliteModel.outputs);
                console.log("Full model:", tfliteModel);
                
                inspectionSection.classList.remove('hidden');
                runBtn.disabled = false;
                inspectModel();

                // Extract and display complete model data
                modelDataSection.classList.remove('hidden');
                const completeData = extractCompleteModelData(tfliteModel);
                displayCompleteModelData(completeData);
                console.log("Complete Model Data:", completeData);

            } catch (error) {
                updateStatus(`Load error: ${error.message}`, 'error');
                console.error("TFLite error:", error);
                loadBtn.disabled = false;
            }
        }

        // Add cleanup function for when loading a new model
        function cleanupOldModel() {
            if (tfliteModel && typeof tfliteModel.cleanUp === 'function') {
                try {
                    tfliteModel.cleanUp();
                    console.log("Previous model cleaned up");
                } catch (e) {
                    console.warn("Cleanup error:", e);
                }
            }
        }

        function inspectModel() {
            if (!tfliteModel) return;

            // Input signature
            if (tfliteModel.inputs && tfliteModel.inputs.length > 0) {
                const input = tfliteModel.inputs[0];
                inputSummaryEl.textContent = `Input: ${input.name} | Shape: [${input.shape ? input.shape.join(', ') : '?'}] | Type: ${input.dtype}`;
                
                // Auto-populate shape
                if (input.shape && input.shape.length > 0) {
                    const autoShape = input.shape.map(dim => dim === -1 ? 1 : dim);
                    inputShapeEl.value = autoShape.join(', ');
                    console.log(`Auto-detected shape: [${autoShape.join(', ')}]`);
                }
            } else {
                inputSummaryEl.textContent = 'Input: No inputs defined';
                inputSummaryEl.className = 'status status-error';
            }
            
            // Output signature
            if (tfliteModel.outputs && tfliteModel.outputs.length > 0) {
                const output = tfliteModel.outputs[0];
                outputSummaryEl.textContent = `Output: ${output.name} | Shape: [${output.shape ? output.shape.join(', ') : '?'}] | Type: ${output.dtype}`;
            } else {
                outputSummaryEl.textContent = 'Output: No outputs defined';
                outputSummaryEl.className = 'status status-error';
            }

            // Topology
            const topology = getLayerDetails(tfliteModel);
            layerCountSummaryEl.textContent = `Operations: ${topology.count}`;
            layerDetailsListEl.innerHTML = '';

            if (topology.layers.length > 0 && topology.layers[0].op !== "WARNING") {
                topology.layers.slice(0, 5).forEach(layer => {
                    const li = document.createElement('li');
                    li.textContent = `${layer.op}: ${layer.name}`;
                    layerDetailsListEl.appendChild(li);
                });
                
                if (topology.layers.length > 5) {
                    const li = document.createElement('li');
                    li.style.fontStyle = 'italic';
                    li.textContent = `... ${topology.layers.length - 5} more (see console)`;
                    layerDetailsListEl.appendChild(li);
                }
            } else {
                layerDetailsListEl.innerHTML = '<li>Could not extract layers</li>';
            }
        }

        function runInference() {
            if (!tfliteModel) {
                inferenceStatusEl.textContent = 'Model not loaded';
                inferenceStatusEl.className = 'status status-error';
                return;
            }

            const shapeString = inputShapeEl.value.trim();
            if (!shapeString) {
                inferenceStatusEl.textContent = 'Please specify input shape';
                inferenceStatusEl.className = 'status status-error';
                return;
            }

            const inputShape = shapeString.split(',').map(s => parseInt(s.trim()));

            if (inputShape.some(dim => isNaN(dim) || dim <= 0)) {
                inferenceStatusEl.textContent = 'Invalid shape (must be positive integers)';
                inferenceStatusEl.className = 'status status-error';
                return;
            }

            inferenceStatusEl.textContent = `Running inference with shape [${inputShape.join(', ')}]...`;
            inferenceStatusEl.className = 'status status-info';
            runBtn.disabled = true;

            try {
                tf.tidy(() => {
                    const totalElements = inputShape.reduce((a, b) => a * b, 1);
                    const mockData = Array.from({ length: totalElements }, () => Math.random() * 2 - 1);
                    const inputTensor = tf.tensor(mockData, inputShape, 'float32');
                    
                    console.log("Input tensor:", inputTensor);

                    const outputTensor = tfliteModel.predict(inputTensor);
                    
                    console.log("Output tensor:", outputTensor);

                    outputSection.classList.remove('hidden');

                    const outputShape = outputTensor.shape;
                    const outputData = outputTensor.dataSync();

                    outputShapeResultEl.textContent = `Output Shape: [${outputShape.join(', ')}]`;
                    outputDataPreviewEl.textContent = `Preview: [${Array.from(outputData).slice(0, 10).map(v => v.toFixed(4)).join(', ')}${outputData.length > 10 ? ', ...' : ''}]`;

                    inferenceStatusEl.textContent = 'Inference complete';
                    inferenceStatusEl.className = 'status status-loaded';

                    // Get profiling data
                    try {
                        // Get profiling summary - returns a string
                        if (typeof tfliteModel.getProfilingSummary === 'function') {
                            const summary = tfliteModel.getProfilingSummary();
                            console.log("Profiling Summary (string):", summary);
                            profilingSummaryEl.textContent = summary || 'No profiling summary available';
                        } else {
                            profilingSummaryEl.textContent = 'Profiling summary not available (function not found)';
                        }

                        // Get detailed profiling results - returns array of {nodeType, nodeName, execTimeInMs}
                        if (typeof tfliteModel.getProfilingResults === 'function') {
                            const results = tfliteModel.getProfilingResults();
                            console.log("Profiling Results (array):", results);
                            
                            if (results && results.length > 0) {
                                // Sort by execution time (descending) and take top 15
                                const sortedResults = [...results]
                                    .sort((a, b) => (b.execTimeInMs || 0) - (a.execTimeInMs || 0))
                                    .slice(0, 15);
                                
                                // Calculate total time for percentages
                                const totalTime = results.reduce((sum, op) => sum + (op.execTimeInMs || 0), 0);
                                
                                const detailsFormatted = {
                                    totalOperations: results.length,
                                    totalExecutionTime: `${totalTime.toFixed(6)} ms`,
                                    top15Slowest: sortedResults.map(op => ({
                                        name: op.nodeName || 'Unknown',
                                        type: op.nodeType || 'Unknown',
                                        time: `${(op.execTimeInMs || 0).toFixed(6)} ms`,
                                        percentage: totalTime > 0 ? `${((op.execTimeInMs || 0) / totalTime * 100).toFixed(2)}%` : 'N/A'
                                    })),
                                    note: 'Top 15 slowest operations. See console for full list.'
                                };
                                profilingDetailsEl.textContent = JSON.stringify(detailsFormatted, null, 2);
                            } else {
                                profilingDetailsEl.textContent = 'No profiling results returned. Make sure enableProfiling: true was set when loading model.';
                            }
                        } else {
                            profilingDetailsEl.textContent = 'Detailed profiling not available (function not found)';
                        }
                    } catch (profilingError) {
                        console.warn("Profiling error:", profilingError);
                        profilingSummaryEl.textContent = `Profiling unavailable: ${profilingError.message}`;
                        profilingDetailsEl.textContent = `Profiling unavailable: ${profilingError.message}`;
                    }
                });
            } catch (error) {
                inferenceStatusEl.textContent = `Error: ${error.message}`;
                inferenceStatusEl.className = 'status status-error';
                console.error("Inference error:", error);
            } finally {
                runBtn.disabled = false;
                tf.disposeVariables();
            }
        }

        modelFileEl.addEventListener('change', () => {
            if (modelFileEl.files.length > 0) {
                modelUrlEl.value = ''; 
                loadModel();
            }
        });
    </script>
</body>
</html>
