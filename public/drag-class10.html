<!DOCTYPE html>
<html lang="en">
<head>
Â  Â  <meta charset="UTF-8">
Â  Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  Â  <title>Unified FOMO & Classification Detector (LiteRT.js Final Import Fix)</title>

Â  Â  <style>
Â  Â  Â  Â  body {Â 
Â  Â  Â  Â  Â  Â  font-family: 'Inter', sans-serif;
Â  Â  Â  Â  Â  Â  margin: 20px;Â 
Â  Â  Â  Â  Â  Â  background-color: #f0f4f8;
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  min-height: 100vh;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myMainContainer {
Â  Â  Â  Â  Â  Â  max-width: 800px;
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  background: white;
Â  Â  Â  Â  Â  Â  padding: 30px;
Â  Â  Â  Â  Â  Â  border-radius: 12px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 6px 15px rgba(0, 0, 0, 0.15);
Â  Â  Â  Â  }
Â  Â  Â  Â  h1 {
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  color: #3c4043;
Â  Â  Â  Â  Â  Â  font-size: 2em;
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myInstructions {
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  color: #5f6368;
Â  Â  Â  Â  Â  Â  margin-bottom: 20px;
Â  Â  Â  Â  Â  Â  font-size: 0.95em;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myVideo {Â 
Â  Â  Â  Â  Â  Â  display: none;Â 
Â  Â  Â  Â  }
Â  Â  Â  Â  .myButton {
Â  Â  Â  Â  Â  Â  background-color: #1a73e8;Â 
Â  Â  Â  Â  Â  Â  color: white;Â 
Â  Â  Â  Â  Â  Â  padding: 12px 24px;Â 
Â  Â  Â  Â  Â  Â  border: none;Â 
Â  Â  Â  Â  Â  Â  border-radius: 8px;Â 
Â  Â  Â  Â  Â  Â  cursor: pointer;Â 
Â  Â  Â  Â  Â  Â  font-size: 16px;Â 
Â  Â  Â  Â  Â  Â  margin: 5px;
Â  Â  Â  Â  Â  Â  transition: background-color 0.3s, transform 0.1s;
Â  Â  Â  Â  Â  Â  font-weight: 600;
Â  Â  Â  Â  }
Â  Â  Â  Â  .myButton:hover {Â 
Â  Â  Â  Â  Â  Â  background-color: #155cb8;Â 
Â  Â  Â  Â  }
Â  Â  Â  Â  .myButton:active {
Â  Â  Â  Â  Â  Â  transform: translateY(1px);
Â  Â  Â  Â  }
Â  Â  Â  Â  .myButton:disabled {
Â  Â  Â  Â  Â  Â  background-color: #ccc;
Â  Â  Â  Â  Â  Â  cursor: not-allowed;
Â  Â  Â  Â  }
Â  Â  Â  Â  .myButton.stop {
Â  Â  Â  Â  Â  Â  background-color: #d93025;
Â  Â  Â  Â  }
Â  Â  Â  Â  .myButton.stop:hover {
Â  Â  Â  Â  Â  Â  background-color: #b02419;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myControlSection {
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  margin-bottom: 20px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myStatusMessage {
Â  Â  Â  Â  Â  Â  font-size: 1em;
Â  Â  Â  Â  Â  Â  margin: 15px 0;
Â  Â  Â  Â  Â  Â  color: #3c4043;
Â  Â  Â  Â  Â  Â  font-weight: 500;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  padding: 12px;
Â  Â  Â  Â  Â  Â  background-color: #e6f7ff;
Â  Â  Â  Â  Â  Â  border: 1px solid #90caff;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myCanvasContainer {
Â  Â  Â  Â  Â  Â  position: relative;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  margin-top: 20px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myCanvas {Â 
Â  Â  Â  Â  Â  Â  border: 3px solid #1a73e8;
Â  Â  Â  Â  Â  Â  border-radius: 8px;Â 
Â  Â  Â  Â  Â  Â  background-color: #333;Â 
Â  Â  Â  Â  Â  Â  width: 100%;Â 
Â  Â  Â  Â  Â  Â  height: auto;
Â  Â  Â  Â  Â  Â  max-width: 600px;Â 
Â  Â  Â  Â  Â  Â  aspect-ratio: 1 / 1;
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  margin: 0 auto;
Â  Â  Â  Â  Â  Â  transition: border-color 0.3s;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myCanvas.drag-over {
Â  Â  Â  Â  Â  Â  border-color: #0f9d58;
Â  Â  Â  Â  Â  Â  border-style: dashed;
Â  Â  Â  Â  Â  Â  border-width: 4px;
Â  Â  Â  Â  Â  Â  background-color: #e8f5e9;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myDropOverlay {
Â  Â  Â  Â  Â  Â  position: absolute;
Â  Â  Â  Â  Â  Â  top: 0;
Â  Â  Â  Â  Â  Â  left: 50%;
Â  Â  Â  Â  Â  Â  transform: translateX(-50%);
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  max-width: 600px;
Â  Â  Â  Â  Â  Â  height: 100%;
Â  Â  Â  Â  Â  Â  background-color: rgba(15, 157, 88, 0.1);
Â  Â  Â  Â  Â  Â  border: 4px dashed #0f9d58;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  Â  Â  justify-content: center;
Â  Â  Â  Â  Â  Â  align-items: center;
Â  Â  Â  Â  Â  Â  pointer-events: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myDropOverlay.active {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myDropText {
Â  Â  Â  Â  Â  Â  font-size: 1.5em;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: #0f9d58;
Â  Â  Â  Â  Â  Â  background-color: white;
Â  Â  Â  Â  Â  Â  padding: 20px 40px;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
Â  Â  Â  Â  }
Â  Â  Â  Â  .myModelInfo {
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  margin-top: 15px;
Â  Â  Â  Â  Â  Â  padding: 12px;
Â  Â  Â  Â  Â  Â  background-color: #f8f9fa;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  border: 1px solid #dee2e6;
Â  Â  Â  Â  }
Â  Â  Â  Â  .myInfoLabel {
Â  Â  Â  Â  Â  Â  font-size: 0.85em;
Â  Â  Â  Â  Â  Â  color: #6c757d;
Â  Â  Â  Â  Â  Â  font-weight: 600;
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  margin-bottom: 5px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .myInfoValue {
Â  Â  Â  Â  Â  Â  font-size: 0.95em;
Â  Â  Â  Â  Â  Â  color: #212529;
Â  Â  Â  Â  Â  Â  font-family: monospace;
Â  Â  Â  Â  }
Â  Â  Â  Â  .myInputGroup {
Â  Â  Â  Â  Â  Â  display: flex;
Â  Â  Â  Â  Â  Â  gap: 5px;
Â  Â  Â  Â  Â  Â  margin-bottom: 10px;
Â  Â  Â  Â  }
Â  Â  Â  Â  .myInputGroup input[type="text"] {
Â  Â  Â  Â  Â  Â  flex-grow: 1;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  border: 1px solid #ccc;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  font-size: 16px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myLabelEditor {
Â  Â  Â  Â  Â  Â  width: 100%;
Â  Â  Â  Â  Â  Â  height: 80px;
Â  Â  Â  Â  Â  Â  padding: 10px;
Â  Â  Â  Â  Â  Â  box-sizing: border-box;
Â  Â  Â  Â  Â  Â  border: 1px solid #ccc;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  font-family: monospace;
Â  Â  Â  Â  Â  Â  font-size: 14px;
Â  Â  Â  Â  Â  Â  margin-bottom: 15px;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myResultDisplay {
Â  Â  Â  Â  Â  Â  margin-top: 20px;
Â  Â  Â  Â  Â  Â  padding: 15px;
Â  Â  Â  Â  Â  Â  border-radius: 8px;
Â  Â  Â  Â  Â  Â  background-color: #e6ffe6;
Â  Â  Â  Â  Â  Â  border: 2px solid #0f9d58;
Â  Â  Â  Â  Â  Â  text-align: center;
Â  Â  Â  Â  Â  Â  font-size: 1.5em;
Â  Â  Â  Â  Â  Â  font-weight: bold;
Â  Â  Â  Â  Â  Â  color: #0f9d58;
Â  Â  Â  Â  Â  Â  display: none;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myResultDisplay.active {
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myResultLabel {
Â  Â  Â  Â  Â  Â  font-size: 1.8em;
Â  Â  Â  Â  Â  Â  color: #0c8046;
Â  Â  Â  Â  Â  Â  margin-top: 5px;
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  }
Â  Â  Â  Â  #myResultConfidence {
Â  Â  Â  Â  Â  Â  font-size: 1em;
Â  Â  Â  Â  Â  Â  color: #3c4043;
Â  Â  Â  Â  Â  Â  display: block;
Â  Â  Â  Â  Â  Â  margin-top: 5px;
Â  Â  Â  Â  }
Â  Â  </style>
Â  Â Â 
</head>
<body>

Â  Â  <script type="module">
        // =================================================================
        // ğŸ“¦ LITE RT.JS MODULE IMPORTS
        // =================================================================
        import * as LiteRT from 'https://cdn.jsdelivr.net/npm/@litertjs/core@0.2.1/+esm';
        // âš ï¸ CORRECTED IMPORT: Use namespace import for tfjs-interop
        import * as TFLiteInteropModule from 'https://cdn.jsdelivr.net/npm/@litertjs/tfjs-interop/+esm';
        import 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js';
        import 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu/dist/tf-backend-webgpu.js';

Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â  // ğŸš€ DEFAULT CONFIGURATION (FOMO Model)
Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â  const myDefaultConfig = {
Â  Â  Â  Â  Â  Â  myDefaultUrl: 'https://hpssjellis.github.io/my-examples-of-liteRTjs/public/tflite/MINST.tflite',
Â  Â  Â  Â  Â  Â  myInputResolution: 320,
Â  Â  Â  Â  Â  Â  myGridScaleFactor: 8,
Â  Â  Â  Â  Â  Â  myConfidenceThreshold: 0.5,
Â  Â  Â  Â  Â  Â  myClassLabels: ['background', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
Â  Â  Â  Â  Â  Â  myInputChannels: 3,
Â  Â  Â  Â  Â  Â  myModelType: 'fomo', // 'fomo' or 'classification'
Â  Â  Â  Â  Â  Â  myGithubRepoPath: 'hpssjellis/my-examples-of-liteRTjs/main/public/tflite' // user/repo/branch/path
Â  Â  Â  Â  };

Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â  // âš™ï¸ GLOBAL VARIABLESÂ 
Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â  let myVideoElement = null;
Â  Â  Â  Â  let myIsWebcamReady = false;
Â  Â  Â  Â  let myAnimationFrameId = null;
Â  Â  Â  Â  let myStatusElement = null;
Â  Â  Â  Â  let myStartButton = null;
Â  Â  Â  Â  let myStopButton = null;
Â  Â  Â  Â  let myCanvas = null;
Â  Â  Â  Â  let myContext = null;
Â  Â  Â  Â  let myDropOverlay = null;
Â  Â  Â  Â  let myModelInfo = null;
Â  Â  Â  Â  let myUrlInput = null;
Â  Â  Â  Â  let myFileInput = null;
Â  Â  Â  Â  let myLabelEditor = null;
Â  Â  Â  Â  let myResultDisplay = null;
Â  Â  Â  Â  let myModelSelect = null;
Â  Â  Â  Â Â 
Â  Â  Â  Â  let myModel = null;
Â  Â  Â  Â  let myCurrentConfig = {...myDefaultConfig};
Â  Â  Â  Â  let myCurrentModelName = 'Default Model';
Â  Â  Â  Â  let myCurrentModelSize = 0;

Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â  // ğŸ  HTML SETUP
Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â Â 
Â  Â  Â  Â  function myCreateDOM() {
Â  Â  Â  Â  Â  Â  const myMainContainer = document.createElement('div');
Â  Â  Â  Â  Â  Â  myMainContainer.id = 'myMainContainer';
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const myTitle = document.createElement('h1');
Â  Â  Â  Â  Â  Â  myTitle.textContent = 'Edge Impulse Model Detector';
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myTitle);

Â  Â  Â  Â  Â  Â  const myInstructions = document.createElement('div');
Â  Â  Â  Â  Â  Â  myInstructions.id = 'myInstructions';
Â  Â  Â  Â  Â  Â  myInstructions.innerHTML = 'Load FOMO or Classification models via URL, File, or Drag & Drop<br><small>Auto-detects model type and properties. Edit labels below.</small>';
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myInstructions);

Â  Â  Â  Â  Â  Â  // Model Select Dropdown
Â  Â  Â  Â  Â  Â  myModelSelect = document.createElement('select');
Â  Â  Â  Â  Â  Â  myModelSelect.style.cssText = 'width: 100%; padding: 10px; border: 1px solid #ccc; border-radius: 8px; font-size: 16px; background-color: white; margin-bottom: 15px;';
Â  Â  Â  Â  Â  Â  myModelSelect.innerHTML = '<option value="">Loading models from GitHub...</option>';
Â  Â  Â  Â  Â  Â  myModelSelect.onchange = myHandleModelSelect;
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myModelSelect);

Â  Â  Â  Â  Â  Â  // URL Upload
Â  Â  Â  Â  Â  Â  const myUrlGroup = document.createElement('div');
Â  Â  Â  Â  Â  Â  myUrlGroup.className = 'myInputGroup';
Â  Â  Â  Â  Â  Â  myUrlInput = document.createElement('input');
Â  Â  Â  Â  Â  Â  myUrlInput.type = 'text';
Â  Â  Â  Â  Â  Â  myUrlInput.placeholder = 'Paste Model URL (.tflite or .lite)';
Â  Â  Â  Â  Â  Â  myUrlInput.value = myDefaultConfig.myDefaultUrl;
Â  Â  Â  Â  Â  Â  myUrlGroup.appendChild(myUrlInput);
Â  Â  Â  Â  Â  Â  const myUrlButton = document.createElement('button');
Â  Â  Â  Â  Â  Â  myUrlButton.className = 'myButton';
Â  Â  Â  Â  Â  Â  myUrlButton.textContent = 'Load from URL';
Â  Â  Â  Â  Â  Â  myUrlButton.onclick = () => myLoadModelFromUrl(myUrlInput.value);
Â  Â  Â  Â  Â  Â  myUrlGroup.appendChild(myUrlButton);
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myUrlGroup);

Â  Â  Â  Â  Â  Â  // File Input
Â  Â  Â  Â  Â  Â  myFileInput = document.createElement('input');
Â  Â  Â  Â  Â  Â  myFileInput.type = 'file';
Â  Â  Â  Â  Â  Â  myFileInput.style.marginBottom = '15px';
Â  Â  Â  Â  Â  Â  myFileInput.setAttribute('accept', '.tflite,.lite');
Â  Â  Â  Â  Â  Â  myFileInput.onchange = myHandleFileInput;
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myFileInput);

Â  Â  Â  Â  Â  Â  // Model info display
Â  Â  Â  Â  Â  Â  myModelInfo = document.createElement('div');
Â  Â  Â  Â  Â  Â  myModelInfo.className = 'myModelInfo';
Â  Â  Â  Â  Â  Â  myModelInfo.innerHTML = `
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoLabel">Model:</span>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoValue" id="myModelName">No model loaded</span><br>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoLabel">Type:</span>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoValue" id="myModelType">Unknown</span><br>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoLabel">Size:</span>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoValue" id="myModelSize">N/A</span><br>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoLabel">Config:</span>
Â  Â  Â  Â  Â  Â  Â  Â  <span class="myInfoValue" id="myModelConfig">N/A</span>
Â  Â  Â  Â  Â  Â  `;
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myModelInfo);

Â  Â  Â  Â  Â  Â  // Labels Textarea
Â  Â  Â  Â  Â  Â  const myLabelHeader = document.createElement('div');
Â  Â  Â  Â  Â  Â  myLabelHeader.style.cssText = 'font-size: 0.9em; margin-top: 15px; margin-bottom: 5px; font-weight: bold; color: #3c4043;';
Â  Â  Â  Â  Â  Â  myLabelHeader.textContent = 'Class Labels (Comma-separated)';
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myLabelHeader);
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  myLabelEditor = document.createElement('textarea');
Â  Â  Â  Â  Â  Â  myLabelEditor.id = 'myLabelEditor';
Â  Â  Â  Â  Â  Â  myLabelEditor.placeholder = 'Enter labels here (e.g., background, Object1, Object2)';
Â  Â  Â  Â  Â  Â  myLabelEditor.oninput = myUpdateConfigFromLabels;
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myLabelEditor);

Â  Â  Â  Â  Â  Â  // Control section
Â  Â  Â  Â  Â  Â  const myControlSection = document.createElement('div');
Â  Â  Â  Â  Â  Â  myControlSection.id = 'myControlSection';
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  myStatusElement = document.createElement('div');
Â  Â  Â  Â  Â  Â  myStatusElement.id = 'myStatusMessage';
Â  Â  Â  Â  Â  Â  myStatusElement.textContent = 'Click "Start" to begin';
Â  Â  Â  Â  Â  Â  myControlSection.appendChild(myStatusElement);

Â  Â  Â  Â  Â  Â  myStartButton = document.createElement('button');
Â  Â  Â  Â  Â  Â  myStartButton.className = 'myButton';
Â  Â  Â  Â  Â  Â  myStartButton.textContent = 'Start Webcam & Load Default Model';
Â  Â  Â  Â  Â  Â  myStartButton.onclick = myStartAll;
Â  Â  Â  Â  Â  Â  myControlSection.appendChild(myStartButton);

Â  Â  Â  Â  Â  Â  myStopButton = document.createElement('button');
Â  Â  Â  Â  Â  Â  myStopButton.className = 'myButton stop';
Â  Â  Â  Â  Â  Â  myStopButton.textContent = 'Stop Webcam';
Â  Â  Â  Â  Â  Â  myStopButton.onclick = myStopAll;
Â  Â  Â  Â  Â  Â  myStopButton.disabled = true;
Â  Â  Â  Â  Â  Â  myControlSection.appendChild(myStopButton);

Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myControlSection);

Â  Â  Â  Â  Â  Â  // Hidden video element
Â  Â  Â  Â  Â  Â  myVideoElement = document.createElement('video');
Â  Â  Â  Â  Â  Â  myVideoElement.id = 'myVideo';
Â  Â  Â  Â  Â  Â  myVideoElement.setAttribute('playsinline', '');
Â  Â  Â  Â  Â  Â  myVideoElement.setAttribute('autoplay', '');
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myVideoElement);

Â  Â  Â  Â  Â  Â  // Canvas container with drop overlay
Â  Â  Â  Â  Â  Â  const myCanvasContainer = document.createElement('div');
Â  Â  Â  Â  Â  Â  myCanvasContainer.id = 'myCanvasContainer';

Â  Â  Â  Â  Â  Â  myCanvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  myCanvas.id = 'myCanvas';
Â  Â  Â  Â  Â  Â  myCanvas.width = myCurrentConfig.myInputResolution;
Â  Â  Â  Â  Â  Â  myCanvas.height = myCurrentConfig.myInputResolution;
Â  Â  Â  Â  Â  Â  myContext = myCanvas.getContext('2d');
Â  Â  Â  Â  Â  Â  myCanvasContainer.appendChild(myCanvas);

Â  Â  Â  Â  Â  Â  myDropOverlay = document.createElement('div');
Â  Â  Â  Â  Â  Â  myDropOverlay.id = 'myDropOverlay';
Â  Â  Â  Â  Â  Â  const myDropText = document.createElement('div');
Â  Â  Â  Â  Â  Â  myDropText.id = 'myDropText';
Â  Â  Â  Â  Â  Â  myDropText.textContent = 'Drop .tflite or .lite file here';
Â  Â  Â  Â  Â  Â  myDropOverlay.appendChild(myDropText);
Â  Â  Â  Â  Â  Â  myCanvasContainer.appendChild(myDropOverlay);

Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myCanvasContainer);

Â  Â  Â  Â  Â  Â  // Classification Result Display
Â  Â  Â  Â  Â  Â  myResultDisplay = document.createElement('div');
Â  Â  Â  Â  Â  Â  myResultDisplay.id = 'myResultDisplay';
Â  Â  Â  Â  Â  Â  myResultDisplay.innerHTML = 'Classification Result:<span id="myResultLabel">Awaiting Input...</span><span id="myResultConfidence"></span>';
Â  Â  Â  Â  Â  Â  myMainContainer.appendChild(myResultDisplay);

Â  Â  Â  Â  Â  Â  document.body.appendChild(myMainContainer);

Â  Â  Â  Â  Â  Â  mySetupDragAndDrop();
Â  Â  Â  Â  Â  Â  myUpdateLabelEditor();
Â  Â  Â  Â  Â  Â  myLoadGithubModels(); // Load models from GitHub
Â  Â  Â  Â  }

Â  Â  Â  Â  window.onload = myCreateDOM;

Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â  // ğŸ“¦ GITHUB MODEL LOADER
Â  Â  Â  Â  // =================================================================

Â  Â  Â  Â  async function myLoadGithubModels() {
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  // Parse the GitHub path
Â  Â  Â  Â  Â  Â  Â  Â  const myPathParts = myDefaultConfig.myGithubRepoPath.split('/');
Â  Â  Â  Â  Â  Â  Â  Â  const myUser = myPathParts[0];
Â  Â  Â  Â  Â  Â  Â  Â  const myRepo = myPathParts[1];
Â  Â  Â  Â  Â  Â  Â  Â  const myBranch = myPathParts[2];
Â  Â  Â  Â  Â  Â  Â  Â  const myFolderPath = myPathParts.slice(3).join('/');
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // GitHub API URL
Â  Â  Â  Â  Â  Â  Â  Â  const myApiUrl = `https://api.github.com/repos/${myUser}/${myRepo}/contents/${myFolderPath}?ref=${myBranch}`;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  console.log('Fetching models from:', myApiUrl);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const myResponse = await fetch(myApiUrl);
Â  Â  Â  Â  Â  Â  Â  Â  if (!myResponse.ok) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  throw new Error(`GitHub API error: ${myResponse.status}`);
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  const myFiles = await myResponse.json();
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Filter for .tflite and .lite files
Â  Â  Â  Â  Â  Â  Â  Â  const myModelFiles = myFiles.filter(myFile =>Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myFile.name.endsWith('.tflite') || myFile.name.endsWith('.lite')
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  if (myModelFiles.length === 0) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myModelSelect.innerHTML = '<option value="">No models found in repository</option>';
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Populate select box
Â  Â  Â  Â  Â  Â  Â  Â  myModelSelect.innerHTML = '<option value="">-- Select a Model --</option>';
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  myModelFiles.forEach(myFile => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const myOption = document.createElement('option');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Build proper GitHub Pages URL
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  // Format: https://username.github.io/repository/path/to/file
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  const myGithubPagesUrl = `https://${myUser}.github.io/${myRepo}/${myFolderPath}/${myFile.name}`;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myOption.value = myGithubPagesUrl;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myOption.textContent = myFile.name;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myModelSelect.appendChild(myOption);
Â  Â  Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  console.log(`Loaded ${myModelFiles.length} models from GitHub`);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  } catch (myError) {
Â  Â  Â  Â  Â  Â  Â  Â  console.error('Failed to load GitHub models:', myError);
Â  Â  Â  Â  Â  Â  Â  Â  myModelSelect.innerHTML = '<option value="">Failed to load models (check console)</option>';
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  function myHandleModelSelect() {
Â  Â  Â  Â  Â  Â  if (myModelSelect.value) {
Â  Â  Â  Â  Â  Â  Â  Â  myUrlInput.value = myModelSelect.value;
Â  Â  Â  Â  Â  Â  Â  Â  // Automatically load the selected model
Â  Â  Â  Â  Â  Â  Â  Â  myLoadModelFromUrl(myModelSelect.value);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  // =================================================================
Â  Â  Â  Â  // ğŸ¯ DRAG AND DROP / FILE INPUT HANDLERS
Â  Â  Â  Â  // =================================================================

Â  Â  Â  Â  function mySetupDragAndDrop() {
Â  Â  Â  Â  Â  Â  ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(myEventName => {
Â  Â  Â  Â  Â  Â  Â  Â  document.body.addEventListener(myEventName, myPreventDefaults, false);
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  function myPreventDefaults(myEvent) {
Â  Â  Â  Â  Â  Â  Â  Â  myEvent.preventDefault();
Â  Â  Â  Â  Â  Â  Â  Â  myEvent.stopPropagation();
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  ['dragenter', 'dragover'].forEach(myEventName => {
Â  Â  Â  Â  Â  Â  Â  Â  myCanvas.addEventListener(myEventName, () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myCanvas.classList.add('drag-over');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myDropOverlay.classList.add('active');
Â  Â  Â  Â  Â  Â  Â  Â  }, false);
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  ['dragleave', 'drop'].forEach(myEventName => {
Â  Â  Â  Â  Â  Â  Â  Â  myCanvas.addEventListener(myEventName, () => {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myCanvas.classList.remove('drag-over');
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myDropOverlay.classList.remove('active');
Â  Â  Â  Â  Â  Â  Â  Â  }, false);
Â  Â  Â  Â  Â  Â  });

Â  Â  Â  Â  Â  Â  myCanvas.addEventListener('drop', myHandleDrop, false);
Â  Â  Â  Â  }

Â  Â  Â  Â  function myHandleDrop(myEvent) {
Â  Â  Â  Â  Â  Â  const myDataTransfer = myEvent.dataTransfer;
Â  Â  Â  Â  Â  Â  const myDroppedFiles = myDataTransfer.files;

Â  Â  Â  Â  Â  Â  if (myDroppedFiles.length > 0) {
Â  Â  Â  Â  Â  Â  Â  Â  const myFile = myDroppedFiles[0];
Â  Â  Â  Â  Â  Â  Â  Â  if (myFile.name.endsWith('.tflite') || myFile.name.endsWith('.lite')) {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myLoadModelFromFile(myFile);
Â  Â  Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  myStatusElement.textContent = 'Error: Please drop a .tflite or .lite file';
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  function myHandleFileInput(myEvent) {
Â  Â  Â  Â  Â  Â  const myFile = myEvent.target.files[0];
Â  Â  Â  Â  Â  Â  if (myFile) {
Â  Â  Â  Â  Â  Â  Â  Â  myLoadModelFromFile(myFile);
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }


        // =================================================================
        // ğŸ› ï¸ MODEL LOADING FUNCTIONS (LITERT.JS IMPLEMENTATION)
        // =================================================================

        async function myLoadModelFromFile(myFile) {
            myStatusElement.textContent = `Loading model from file: ${myFile.name}...`;
            try {
                const myBuffer = await myFile.arrayBuffer();
                await myLoadModel(myBuffer, myFile.name);
            } catch (myError) {
                myStatusElement.textContent = `Error loading file: ${myError.message}`;
            }
        }

        async function myLoadModelFromUrl(myUrl) {
            myStatusElement.textContent = `Loading model from URL: ${myUrl}...`;
            try {
                const myModelName = myUrl.substring(myUrl.lastIndexOf('/') + 1);
                await myLoadModel(myUrl, myModelName);
            } catch (myError) {
                myStatusElement.textContent = `Error loading URL: ${myError.message}`;
            }
        }

        async function myLoadModel(mySource, myModelName) {
            try {
                // ğŸš€ FIX APPLIED HERE: Using TFLiteInteropModule.TFLiteModel.load()
                myModel = await TFLiteInteropModule.TFLiteModel.load(mySource); 
                
                myCurrentModelName = myModelName;
                myCurrentModelSize = (mySource.byteLength || mySource.length) || 0; // Rough size estimate

                myCurrentConfig = myAutoDetectConfig(myModel);
                myUpdateModelInfoDisplay();

                console.log(`Model loaded: ${myModelName} (Type: ${myCurrentConfig.myModelType})`);
                myStatusElement.textContent = `Model loaded: ${myModelName} (${myCurrentConfig.myModelType.toUpperCase()})`;

            } catch (myError) {
                console.error('Model loading error:', myError);
                throw new Error(`Failed to load model: ${myError.message.substring(0, 100)}...`);
            }
        }

        // =================================================================
        // ğŸ” MODEL INTROSPECTION (Intact)
        // =================================================================

        function myAutoDetectConfig(myModel) {
            const myInputs = myModel.inputs;
            const myOutputs = myModel.outputs;

            if (myInputs.length !== 1 || myOutputs.length !== 1) {
                console.warn('Model must have exactly one input and one output tensor.');
                return {...myDefaultConfig, myModelType: 'unknown'};
            }

            const myInput = myInputs[0];
            const myOutput = myOutputs[0];
            const myInputShape = myInput.shape;
            const myOutputShape = myOutput.shape;

            // 1. Detect Input Properties: [1, height, width, channels]
            const myInputResolution = myInputShape[1];
            const myInputChannels = myInputShape[3];

            let myModelType = 'unknown';
            let myGridScaleFactor = 0;
            let myNumClasses = 0;

            // 2. Detect Output Properties (Model Type)
            if (myOutputShape.length === 4) {
                // Likely FOMO or Object Detection: [1, grid_h, grid_w, (4 + num_classes)]
                myModelType = 'fomo';
                myGridScaleFactor = myInputResolution / myOutputShape[1];
                myNumClasses = myOutputShape[3];
                console.log(`Auto-Detected FOMO: Input=${myInputResolution}x${myInputResolution}, Grid=${myOutputShape[1]}, Scale=${myGridScaleFactor}, Classes=${myNumClasses}`);

            } else if (myOutputShape.length === 2) {
                // Likely Classification: [1, num_classes]
                myModelType = 'classification';
                myNumClasses = myOutputShape[1];
                console.log(`Auto-Detected Classification: Input=${myInputResolution}x${myInputResolution}, Classes=${myNumClasses}`);

            } else {
                console.warn('Unknown output shape:', myOutputShape);
            }

            // 3. Update Labels based on detected classes
            let myClassLabels = [...myDefaultConfig.myClassLabels];
            if (myNumClasses > myClassLabels.length) {
                console.warn(`Detected ${myNumClasses} classes, but only have ${myClassLabels.length} labels. Generating placeholders.`);
                myClassLabels = Array.from({ length: myNumClasses }, (_, i) => `Class${i}`);
            } else if (myNumClasses < myClassLabels.length && myNumClasses > 0) {
                myClassLabels = myClassLabels.slice(0, myNumClasses);
            }
            
            myLabelEditor.value = myClassLabels.join(', ');

            return {
                myDefaultUrl: myDefaultConfig.myDefaultUrl,
                myInputResolution,
                myGridScaleFactor,
                myConfidenceThreshold: myDefaultConfig.myConfidenceThreshold,
                myClassLabels,
                myInputChannels,
                myModelType,
                myGithubRepoPath: myDefaultConfig.myGithubRepoPath
            };
        }


        // =================================================================
        // ğŸ¨ UI & DATA UPDATE FUNCTIONS (Intact)
        // =================================================================

        function myUpdateConfigFromLabels() {
            const myLabelText = myLabelEditor.value.trim();
            if (myLabelText) {
                myCurrentConfig.myClassLabels = myLabelText.split(',').map(l => l.trim()).filter(l => l.length > 0);
                myUpdateModelInfoDisplay();
            }
        }

        function myUpdateLabelEditor() {
            myLabelEditor.value = myCurrentConfig.myClassLabels.join(', ');
        }

        function myUpdateModelInfoDisplay() {
            document.getElementById('myModelName').textContent = myCurrentModelName;
            document.getElementById('myModelType').textContent = myCurrentConfig.myModelType.toUpperCase();
            document.getElementById('myModelSize').textContent = myCurrentModelSize > 0 ? (myCurrentModelSize / (1024 * 1024)).toFixed(2) + ' MB' : 'N/A';
            document.getElementById('myModelConfig').textContent = 
                `Input: ${myCurrentConfig.myInputResolution}x${myCurrentConfig.myInputResolution}x${myCurrentConfig.myInputChannels}, ` +
                `Classes: ${myCurrentConfig.myClassLabels.length}` + 
                (myCurrentConfig.myModelType === 'fomo' ? `, Scale: ${myCurrentConfig.myGridScaleFactor}` : '');
            myUpdateLabelEditor();
            
            // Toggle result display visibility
            if (myCurrentConfig.myModelType === 'classification') {
                myResultDisplay.classList.add('active');
                myCanvas.style.marginBottom = '10px';
            } else {
                myResultDisplay.classList.remove('active');
                myCanvas.style.marginBottom = '0';
            }
        }
        
        // =================================================================
        // â¯ï¸ WEBCAM AND INFERENCE LOOP (Intact)
        // =================================================================

        function myStartAll() {
            if (myIsWebcamReady) {
                myStatusElement.textContent = 'Webcam already started.';
                return;
            }

            myStartWebcam().then(() => {
                myIsWebcamReady = true;
                myStartButton.disabled = true;
                myStopButton.disabled = false;
                myStatusElement.textContent = 'Webcam started. Loading default model...';
                
                // Load default model after webcam starts
                myLoadModelFromUrl(myCurrentConfig.myDefaultUrl).then(() => {
                    myRunInferenceLoop();
                }).catch(myError => {
                    myStatusElement.textContent = `Error during default model load: ${myError.message}`;
                    console.error('Error during default model load:', myError);
                    myStopWebcam();
                });
            }).catch(myError => {
                myStatusElement.textContent = `Webcam Error: ${myError.message}`;
                console.error('Webcam access error:', myError);
            });
        }

        async function myStartWebcam() {
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                const myStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: 'environment' } 
                });
                myVideoElement.srcObject = myStream;
                return new Promise(myResolve => {
                    myVideoElement.onloadedmetadata = () => {
                        myVideoElement.play();
                        myResolve();
                    };
                });
            } else {
                return Promise.reject(new Error('Webcam not supported or permission denied.'));
            }
        }
        
        function myStopWebcam() {
            if (myVideoElement && myVideoElement.srcObject) {
                myVideoElement.srcObject.getTracks().forEach(track => track.stop());
                myVideoElement.srcObject = null;
            }
        }

        function myStopAll() {
            myStopWebcam();
            myIsWebcamReady = false;
            myStartButton.disabled = false;
            myStopButton.disabled = true;
            if (myAnimationFrameId) {
                cancelAnimationFrame(myAnimationFrameId);
                myAnimationFrameId = null;
            }
            myStatusElement.textContent = 'Webcam stopped. Click "Start" to begin.';
        }

        function myRunInferenceLoop() {
            if (!myIsWebcamReady || !myModel) {
                console.log('Inference loop stopped or awaiting model.');
                return;
            }

            tf.engine().startScope();

            myContext.drawImage(myVideoElement, 0, 0, myCanvas.width, myCanvas.height);

            const myInputTensor = myPreProcess(myCanvas);
            
            // This is the core prediction step
            // This assumes LiteRT.js model provides a .predict method compatible with TF.js tensors.
            const myOutputTensor = myModel.predict(myInputTensor);

            if (myCurrentConfig.myModelType === 'fomo') {
                myPostProcessFOMO(myOutputTensor);
            } else if (myCurrentConfig.myModelType === 'classification') {
                myPostProcessClassification(myOutputTensor);
            }

            myInputTensor.dispose();
            myOutputTensor.dispose();

            tf.engine().endScope();
            
            myAnimationFrameId = requestAnimationFrame(myRunInferenceLoop);
        }

        function myPreProcess(mySource) {
            // Converts the canvas image to a tensor and normalizes it
            const myTensor = tf.browser.fromPixels(mySource, myCurrentConfig.myInputChannels)
                .expandDims(0) // Add batch dimension [1, H, W, C]
                .cast('float32')
                .div(127.5)
                .sub(1.0);
            return myTensor;
        }


        // =================================================================
        // ğŸ“Š POST-PROCESSING FUNCTIONS (Intact)
        // =================================================================

        async function myPostProcessFOMO(myOutputTensor) {
            const myScale = myCurrentConfig.myGridScaleFactor;
            const myClasses = myCurrentConfig.myClassLabels;
            const myThreshold = myCurrentConfig.myConfidenceThreshold;
            const myCanvasSize = myCanvas.width;
            const myGridSize = myOutputTensor.shape[1];

            // Get the data synchronously for speed (assuming fast model)
            const myOutputArray = myOutputTensor.dataSync(); 
            
            myContext.fillStyle = 'rgba(0, 0, 0, 0.4)';
            myContext.fillRect(0, 0, myCanvasSize, myCanvasSize); 
            
            for (let r = 0; r < myGridSize; r++) {
                for (let c = 0; c < myGridSize; c++) {
                    
                    let myMaxConfidence = 0;
                    let myMaxClassIndex = 0;
                    
                    // The first channel is 'background', so we start checking from index 1
                    // Index 0 is confidence of background (usually unused)
                    for (let k = 1; k < myClasses.length; k++) {
                        // Index calculation: r * grid_w * num_classes + c * num_classes + k
                        const myIndex = (r * myGridSize * myClasses.length) + (c * myClasses.length) + k;
                        const myConfidence = myOutputArray[myIndex];

                        if (myConfidence > myMaxConfidence) {
                            myMaxConfidence = myConfidence;
                            myMaxClassIndex = k;
                        }
                    }

                    if (myMaxConfidence >= myThreshold) {
                        const myClassLabel = myClasses[myMaxClassIndex];
                        const myX = c * myScale + (myScale / 2);
                        const myY = r * myScale + (myScale / 2);

                        // Draw a circle (centroid)
                        myContext.beginPath();
                        myContext.arc(myX, myY, myScale / 2, 0, 2 * Math.PI);
                        myContext.fillStyle = 'rgba(26, 115, 232, 0.8)';
                        myContext.fill();
                        
                        // Draw Label
                        myContext.fillStyle = 'white';
                        myContext.font = `${myScale * 0.4}px Arial`;
                        myContext.textAlign = 'center';
                        myContext.fillText(myClassLabel, myX, myY + (myScale * 0.15));
                        
                        // Draw Confidence
                        myContext.font = `${myScale * 0.3}px Arial`;
                        myContext.fillText((myMaxConfidence * 100).toFixed(0) + '%', myX, myY - (myScale * 0.25));
                    }
                }
            }
        }

        async function myPostProcessClassification(myOutputTensor) {
            const myClasses = myCurrentConfig.myClassLabels;
            
            // Get the data from the tensor
            const myOutputArray = myOutputTensor.dataSync();

            // Find the index of the highest confidence score
            const myMaxIndex = myOutputArray.indexOf(Math.max(...myOutputArray));
            const myConfidence = myOutputArray[myMaxIndex];
            const myClassLabel = myClasses[myMaxIndex];

            // Update UI
            document.getElementById('myResultLabel').textContent = myClassLabel;
            document.getElementById('myResultConfidence').textContent = `Confidence: ${(myConfidence * 100).toFixed(2)}%`;
            
            // Redraw canvas with opacity for feedback
            myContext.globalAlpha = 1;
            myContext.drawImage(myVideoElement, 0, 0, myCanvas.width, myCanvas.height);
            myContext.globalAlpha = 0.4;
            myContext.fillStyle = myConfidence >= myCurrentConfig.myConfidenceThreshold ? '#0f9d58' : '#d93025';
            myContext.fillRect(0, 0, myCanvas.width, myCanvas.height);
            myContext.globalAlpha = 1;
            
            myContext.fillStyle = 'white';
            myContext.font = '24px Arial';
            myContext.textAlign = 'center';
            myContext.fillText(myClassLabel, myCanvas.width / 2, myCanvas.height / 2);
        }

Â  Â  </script>

</body>
</html>
