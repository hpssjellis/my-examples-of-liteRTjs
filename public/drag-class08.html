<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LiteRT.js Unified FOMO & Classification Detector</title>

    <style>        
        body {             
            margin: 0; 
            padding: 0; 
            height: 100vh; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            justify-content: center; 
            background-color: #f0f4f8; 
            font-family: sans-serif;
        }        
        #myMainContainer {
            max-width: 800px; 
            width: 100%; 
            padding: 20px; 
            box-shadow: 0 0 10px rgba(0,0,0,0.1); 
            margin: 20px auto; 
            background:white;
        }        
        h1 {
            text-align:center; 
            font-size:1.5em; 
            margin-bottom:10px;
        }
        #myInstructions {
            text-align:center; 
            margin-bottom:15px; 
            color:#5f6368; 
            font-size:0.9em;
        }
        .myButton, #myStartButton, #myStopButton {
            padding: 8px 16px; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 14px; 
            margin: 5px;
            background-color: #1a73e8; 
            color: white;
        }
        #myStopButton[disabled] {
            background-color: #ccc;
            cursor: not-allowed;
        }
    </style>

    <script type="module">
        import * as LiteRT from 'https://cdn.jsdelivr.net/npm/@litertjs/core@0.2.1/+esm';
        import * as LiteRTInterop from 'https://cdn.jsdelivr.net/npm/@litertjs/tfjs-interop/+esm';
        import 'https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js';
        
        // =================================================================
        // üöÄ DEFAULT CONFIGURATION
        // =================================================================
        const myDefaultConfig = {
            myDefaultUrl: 'https://hpssjellis.github.io/my-examples-of-liteRTjs/public/tflite/MINST.tflite',
            myInputResolution: 320,
            myGridScaleFactor: 8,
            myConfidenceThreshold: 0.5,
            myClassLabels: ['background', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'],
            myInputChannels: 3,
            myModelType: 'fomo', // 'fomo' or 'classification'
            myGithubRepoPath: 'hpssjellis/my-examples-of-liteRTjs/main/public/tflite' // user/repo/branch/path
        };

        // =================================================================
        // ‚öôÔ∏è GLOBAL VARIABLES 
        // =================================================================
        let myVideoElement = null;
        let myIsWebcamReady = false;
        let myAnimationFrameId = null;
        let myStatusElement = null;
        let myStartButton = null;
        let myStopButton = null;
        let myCanvas = null;
        let myContext = null;
        let myDropOverlay = null;
        let myModelInfo = null;
        let myUrlInput = null;
        let myFileInput = null;
        let myLabelEditor = null;
        let myResultDisplay = null;
        let myModelSelect = null;
        
        let myModel = null; // LiteRT model instance
        let myCurrentConfig = {...myDefaultConfig};
        let myCurrentModelName = 'Default Model';
        let myCurrentModelSize = 0;
        
        // --- LiteRT Global Setup (Run once on load) ---
        async function mySetupLiteRT() {
            try {
                // Must load LiteRT resources once
              //  await LiteRT.loadLiteRt('https://assets.codepen.io/48236/'); 
                await LiteRT.loadLiteRt('https://cdn.jsdelivr.net/npm/@litertjs/core@0.2.1/wasm/');
                console.log("LiteRT.js environment loaded successfully.");
            } catch (e) {
                console.error("Failed to load LiteRT.js environment:", e);
                // Fallback to TFLite or display error if necessary
            }
        }
        mySetupLiteRT();

        // =================================================================
        // üì¶ GITHUB MODEL LOADER 
        // =================================================================
        
        async function myLoadGithubModels() {
            try {
                const myPathParts = myDefaultConfig.myGithubRepoPath.split('/');
                const myUser = myPathParts[0];
                const myRepo = myPathParts[1];
                const myBranch = myPathParts[2];
                const myFolderPath = myPathParts.slice(3).join('/');
                const myApiUrl = `https://api.github.com/repos/${myUser}/${myRepo}/contents/${myFolderPath}?ref=${myBranch}`;
                const myResponse = await fetch(myApiUrl);
                if (!myResponse.ok) {
                    throw new Error(`GitHub API error: ${myResponse.status}`);
                }
                const myFiles = await myResponse.json();
                const myModelFiles = myFiles.filter(myFile => 
                    myFile.name.endsWith('.tflite') || myFile.name.endsWith('.lite')
                );
                
                myModelSelect.innerHTML = '<option value="">-- Select a Model --</option>';
                myModelFiles.forEach(myFile => {
                    const myOption = document.createElement('option');
                    const myGithubPagesUrl = `https://${myUser}.github.io/${myRepo}/${myFolderPath}/${myFile.name}`;
                    myOption.value = myGithubPagesUrl;
                    myOption.textContent = myFile.name;
                    myModelSelect.appendChild(myOption);
                });
            } catch (myError) {
                console.error('Failed to load GitHub models:', myError);
                myModelSelect.innerHTML = '<option value="">Failed to load models</option>';
            }
        }

        function myHandleModelSelect() {
            if (myModelSelect.value) {
                myUrlInput.value = myModelSelect.value;
                myLoadModelFromUrl(myModelSelect.value);
            }
        }

        // =================================================================
        // üéØ DRAG AND DROP / FILE INPUT HANDLERS
        // =================================================================
        // No changes to drag and drop setup, only the final loading function call
        function mySetupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(myEventName => {
                document.body.addEventListener(myEventName, myPreventDefaults, false);
            });
            function myPreventDefaults(myEvent) {
                myEvent.preventDefault();
                myEvent.stopPropagation();
            }
            ['dragenter', 'dragover'].forEach(myEventName => {
                myCanvas.addEventListener(myEventName, () => {
                    // Removed classList code, keeping minimal inline style approach
                    myDropOverlay.style.display = 'flex';
                    myCanvas.style.borderColor = 'green';
                }, false);
            });
            ['dragleave', 'drop'].forEach(myEventName => {
                myCanvas.addEventListener(myEventName, () => {
                    myDropOverlay.style.display = 'none';
                    myCanvas.style.borderColor = 'black';
                }, false);
            });
            myCanvas.addEventListener('drop', myHandleDrop, false);
        }

        function myHandleDrop(myEvent) {
            const myDataTransfer = myEvent.dataTransfer;
            const myDroppedFiles = myDataTransfer.files;

            if (myDroppedFiles.length > 0) {
                const myFile = myDroppedFiles[0];
                if (myFile.name.endsWith('.tflite') || myFile.name.endsWith('.lite')) {
                    myLoadModelFromFile(myFile); // Call updated file loading function
                } else {
                    myStatusElement.textContent = 'Error: Please drop a .tflite or .lite file';
                }
            }
        }

        function myHandleFileInput(myEvent) {
            const myFile = myEvent.target.files[0];
            if (myFile) {
                myLoadModelFromFile(myFile); // Call updated file loading function
            }
        }

        // =================================================================
        // üîç CONFIGURATION AND LABEL MANAGEMENT
        // =================================================================
        // Note: myAutoDetectConfig uses myModel.inputs and myModel.outputs, which LiteRT models expose!
        function myAutoDetectConfig(myModel) {
            // ... (Your original myAutoDetectConfig function content remains valid) ...
            try {
                const myDetectedConfig = {...myDefaultConfig};
                                
                // Detect Input Size and Channels
                if (myModel.inputs && myModel.inputs.length > 0) {
                    const myInput = myModel.inputs[0];
                    // LiteRT model exposes input tensor shape directly
                    if (myInput.shape && myInput.shape.length === 4) { 
                        const myHeight = myInput.shape[1];
                        const myWidth = myInput.shape[2];
                        const myChannels = myInput.shape[3];
                        if (myHeight === myWidth && myHeight > 0) myDetectedConfig.myInputResolution = myHeight;
                        if (myChannels === 1 || myChannels === 3) myDetectedConfig.myInputChannels = myChannels;
                    }
                }
                                
                // Detect Model Type from Output Shape
                if (myModel.outputs && myModel.outputs.length > 0) {
                    const myOutput = myModel.outputs[0];
                                        
                    if (myOutput.shape.length === 4) {
                        // FOMO Model: [1, gridH, gridW, numClasses]
                        myDetectedConfig.myModelType = 'fomo';
                        const myGridH = myOutput.shape[1];
                        const myNumClasses = myOutput.shape[3];
                                                
                        if (myGridH > 0 && myDetectedConfig.myInputResolution > 0) {
                            const myCalculatedFactor = myDetectedConfig.myInputResolution / myGridH;
                            if (myCalculatedFactor > 0 && Number.isInteger(myCalculatedFactor)) {
                                myDetectedConfig.myGridScaleFactor = myCalculatedFactor;
                            }
                        }
                        // Label initialization based on numClasses (same as original)
                        if (myNumClasses > 0 && myNumClasses !== myCurrentConfig.myClassLabels.length) {
                            myDetectedConfig.myClassLabels = ['background'];
                            for (let i = 1; i < myNumClasses; i++) {
                                myDetectedConfig.myClassLabels.push(`Object${i}`);
                            }
                        } else {
                            myDetectedConfig.myClassLabels = myCurrentConfig.myClassLabels;
                        }

                    } else if (myOutput.shape.length === 2) {
                        // Classification Model: [1, numClasses]
                        myDetectedConfig.myModelType = 'classification';
                        const myNumClasses = myOutput.shape[1];
                        // Label initialization based on numClasses (same as original)
                        if (myNumClasses > 0 && myNumClasses !== myCurrentConfig.myClassLabels.length) {
                            myDetectedConfig.myClassLabels = [];
                            for (let i = 0; i < myNumClasses; i++) {
                                myDetectedConfig.myClassLabels.push(`Class${i}`);
                            }
                        } else {
                            myDetectedConfig.myClassLabels = myCurrentConfig.myClassLabels;
                        }
                    } else {
                        console.warn('Unknown output shape:', myOutput.shape);
                        myDetectedConfig.myModelType = 'unknown';
                    }
                }
                                
                myCanvas.width = myDetectedConfig.myInputResolution;
                myCanvas.height = myDetectedConfig.myInputResolution;
                
                return myDetectedConfig;
                            } catch (myError) {
                console.error('Auto-detection error:', myError);
                return {...myDefaultConfig};
            }
        }
        
        function myUpdateModelInfoDisplay() {
            document.getElementById('myModelName').textContent = myCurrentModelName;
            document.getElementById('myModelType').textContent = myCurrentConfig.myModelType.toUpperCase();
                        
            let mySizeText = 'N/A';
            if (myCurrentModelSize > 0) {
                if (myCurrentModelSize < 1024) {
                    mySizeText = `${myCurrentModelSize} bytes`;
                } else if (myCurrentModelSize < 1024 * 1024) {
                    mySizeText = `${(myCurrentModelSize / 1024).toFixed(2)} KB`;
                } else {
                    mySizeText = `${(myCurrentModelSize / (1024 * 1024)).toFixed(2)} MB`;
                }
            }
            document.getElementById('myModelSize').textContent = mySizeText;
                        
            let myConfigText = `${myCurrentConfig.myInputResolution}x${myCurrentConfig.myInputResolution}, ` +
                `${myCurrentConfig.myInputChannels === 3 ? 'RGB' : 'Grayscale'}, ` +
                `Classes:${myCurrentConfig.myClassLabels.length}`;
                        
            if (myCurrentConfig.myModelType === 'fomo') {
                myConfigText += `, Grid:${myCurrentConfig.myGridScaleFactor}`;
            }
            document.getElementById('myModelConfig').textContent = myConfigText;
                        
            // Show/hide classification result display
            if (myCurrentConfig.myModelType === 'classification') {
                myResultDisplay.style.display = 'block'; // Use inline style
            } else {
                myResultDisplay.style.display = 'none'; // Use inline style
            }
                        
            myUpdateLabelEditor();
        }

        function myUpdateLabelEditor() {
            if (myLabelEditor) {
                myLabelEditor.value = myCurrentConfig.myClassLabels.join(', ');
            }
        }
        
        function myUpdateConfigFromLabels() {
            if (myLabelEditor) {
                const myNewLabels = myLabelEditor.value
                    .split(',')
                    .map(myLabel => myLabel.trim())
                    .filter(myLabel => myLabel.length > 0);
                                
                if (myNewLabels.length === myCurrentConfig.myClassLabels.length) {
                    myCurrentConfig.myClassLabels = myNewLabels;
                    console.log('Labels updated manually:', myCurrentConfig.myClassLabels);
                } else if (myModel) {
                    myStatusElement.textContent = `Warning: Label count must be ${myCurrentConfig.myClassLabels.length}. Current: ${myNewLabels.length}`;
                }
            }
        }

        // =================================================================
        // üíª UNIFIED MODEL LOADING (LiteRT)
        // =================================================================
        
        /**
         * Loads model from a URL, ArrayBuffer, or Blob using LiteRT.load.
         * @param {string|ArrayBuffer|Blob} mySource - The model source.
         * @param {string} myName - Name of the model.
         * @param {number} mySize - File size in bytes.
         */
        async function myLoadModel(mySource, myName, mySize) {
            myStatusElement.textContent = `Loading model ${myName}...`;
            myStartButton.disabled = true;

            try {
                // Use LiteRT.load with the TFJS accelerator
                myModel = await LiteRT.load(mySource, { accelerator: 'tfjs' }); 
                myCurrentModelName = myName;
                myCurrentModelSize = mySize;

                myCurrentConfig = myAutoDetectConfig(myModel);
                myUpdateModelInfoDisplay();

                myStatusElement.textContent = `Model loaded: ${myName} (${myCurrentConfig.myModelType.toUpperCase()})`;
                console.log(`Model loaded: ${myName} (Type: ${myCurrentConfig.myModelType})`);

                if (myIsWebcamReady) {
                    myStatusElement.textContent += ' (Inference running)';
                } else {
                    myStartButton.disabled = false;
                }
            } catch (myError) {
                myStatusElement.textContent = `Failed to load model ${myName}. Check console.`;
                console.error('Model loading error:', myError);
                myModel = null;
                myStartButton.disabled = false;
            }
        }
        
        async function myLoadModelFromUrl(myUrl) {
            if (!myUrl.endsWith('.tflite') && !myUrl.endsWith('.lite')) { 
                 myStatusElement.textContent = 'Error: URL must end with .tflite or .lite'; 
                 return;
            }
            myStatusElement.textContent = `Fetching model from URL...`;
            try {
                // Fetch the model to get the ArrayBuffer and size
                const myResponse = await fetch(myUrl);
                const myArrayBuffer = await myResponse.arrayBuffer();
                const myName = myUrl.substring(myUrl.lastIndexOf('/') + 1);
                
                // Call the unified loading function
                await myLoadModel(myArrayBuffer, myName, myArrayBuffer.byteLength); 
                
            } catch (myError) {
                 myStatusElement.textContent = `Error fetching model: ${myError.message.substring(0, 100)}`;
            }
        }

        async function myLoadModelFromFile(myFile) {
            myStatusElement.textContent = `Reading model file: ${myFile.name}...`;
            try {
                // Read file into ArrayBuffer using async Promise
                const myArrayBuffer = await new Promise((myResolve, myReject) => {
                    const myReader = new FileReader();
                    myReader.onload = () => myResolve(myReader.result);
                    myReader.onerror = myReject;
                    myReader.readAsArrayBuffer(myFile);
                });
                
                // Call the unified loading function
                await myLoadModel(myArrayBuffer, myFile.name, myFile.size);

            } catch (myError) {
                myStatusElement.textContent = `Failed to read file ${myFile.name}. Check console.`;
                console.error('File reading error:', myError);
            }
        }

       // =================================================================        
       // üöÄ START/STOP & INFERENCE (LiteRT Inference)
       // =================================================================
        
        async function myStartAll() {
            myStartButton.disabled = true;
            myStatusElement.textContent = 'Loading default model...';

            try {
                if (!myModel) { 
                     // Use the new URL loading function
                     await myLoadModelFromUrl(myDefaultConfig.myDefaultUrl);
                }
                if (!myModel) throw new Error("Model failed to initialize.");
                
                myStatusElement.textContent = 'Model loaded! Starting webcam...';
                await myStartWebcam();
                
                myStatusElement.textContent = `Running ${myCurrentConfig.myModelType} inference...`;
                myStopButton.disabled = false;
                
            } catch (myError) {
                myStatusElement.textContent = `Error: ${myError.message}`;
                console.error('Startup error:', myError);
                myStartButton.disabled = false;
            }
        }
        
        async function myStartWebcam() {
            if (myIsWebcamReady) return;

            try {
                const myStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: 640,
                        height: 640,
                        facingMode: 'user'
                    },
                    audio: false
                });

                myVideoElement.srcObject = myStream;
                await new Promise(myResolve => myVideoElement.onloadedmetadata = myResolve);
                myVideoElement.play();
                myIsWebcamReady = true;

                console.log('Webcam started');
                myRunInferenceLoop();
            } catch (myError) {
                console.error('Webcam error:', myError);
                throw new Error(`Webcam access failed: ${myError.message}`);
            }
        }

        function myStopWebcam() {
            if (myAnimationFrameId) {
                cancelAnimationFrame(myAnimationFrameId);
                myAnimationFrameId = null;
            }
            if (myVideoElement && myVideoElement.srcObject) {
                myVideoElement.srcObject.getTracks().forEach(myTrack => myTrack.stop());
                myVideoElement.srcObject = null;
            }
            myIsWebcamReady = false;
        }

        function myRunInferenceLoop() {
            if (!myIsWebcamReady || !myModel) {
                myAnimationFrameId = requestAnimationFrame(myRunInferenceLoop);
                return;
            }

            tf.tidy(() => {
                const myInputSize = myCurrentConfig.myInputResolution;

                // 1. Draw video frame to canvas
                myContext.drawImage(myVideoElement, 0, 0, myInputSize, myInputSize);

                // 2. Pre-process input tensor
                let myInputTensor = tf.browser.fromPixels(myCanvas, myCurrentConfig.myInputChannels);
                let myNormalizedTensor = myInputTensor
                    .resizeBilinear([myInputSize, myInputSize])
                    .cast('float32')
                    .div(255.0)
                    .expandDims(0);

                // 3. RUN INFERENCE using LiteRTInterop
                // Returns an array of output Tensors
                const myOutputTensors = LiteRTInterop.runWithTfjsTensors(myModel, myNormalizedTensor);
                const myOutputTensor = myOutputTensors[0]; // Assuming a single output tensor

                // 4. Route to appropriate post-processing based on model type
                if (myCurrentConfig.myModelType === 'fomo') {
                    myPostProcessFomo(myOutputTensor);
                } else if (myCurrentConfig.myModelType === 'classification') {
                    myPostProcessClassification(myOutputTensor);
                }

                // LiteRTInterop Tensors must be disposed manually if not managed by tidy
                for (const t of myOutputTensors) {
                    t.dispose();
                }
            });

            myAnimationFrameId = requestAnimationFrame(myRunInferenceLoop);
        }

        // =================================================================        
        // üìä POST-PROCESSING FUNCTIONS (No Changes Needed)
        // =================================================================
        
        function myPostProcessFomo(myOutputTensor) {
            const myPredictionData = myOutputTensor.dataSync();
            const myOutputShape = myOutputTensor.shape;
            const myNumClasses = myOutputShape[3];
            // Removed unused myGridX/Y
            // const myGridX = myOutputShape[1]; 
            // const myGridY = myOutputShape[2];

            const myInputSize = myCurrentConfig.myInputResolution;
            const myGridSize = myInputSize / myCurrentConfig.myGridScaleFactor;

            if (myCurrentConfig.myClassLabels.length !== myNumClasses) { 
                 myStatusElement.textContent = `ERROR: Label count (${myCurrentConfig.myClassLabels.length}) != Model classes (${myNumClasses})`; 
                 return;
            }

            myContext.drawImage(myVideoElement, 0, 0, myInputSize, myInputSize);

            for (let i = 0; i < myGridSize; i++) {
                for (let j = 0; j < myGridSize; j++) {
                    const myCellStartIndex = (i * myGridSize * myNumClasses) + (j * myNumClasses);

                    let myMaxProbability = 0;
                    let myMaxClassIndex = 0;

                    for (let k = 0; k < myNumClasses; k++) {
                        const myProbability = myPredictionData[myCellStartIndex + k];
                        if (myProbability > myMaxProbability) {
                            myMaxProbability = myProbability;
                            myMaxClassIndex = k;
                        }
                    }

                    if (myMaxClassIndex !== 0 && myMaxProbability >= myCurrentConfig.myConfidenceThreshold) {
                        const myCentroidX = (j * myCurrentConfig.myGridScaleFactor) + (myCurrentConfig.myGridScaleFactor / 2);
                        const myCentroidY = (i * myCurrentConfig.myGridScaleFactor) + (myCurrentConfig.myGridScaleFactor / 2);
                        const myLabel = myCurrentConfig.myClassLabels[myMaxClassIndex] || `Class${myMaxClassIndex}`;

                        // Minimal drawing styles
                        myContext.fillStyle = myMaxClassIndex % 2 === 1 ? 'red' : 'green';
                        myContext.fillRect(myCentroidX - 5, myCentroidY - 5, 10, 10);

                        myContext.font = '12px sans-serif';
                        myContext.fillStyle = 'white';
                        myContext.textAlign = 'center';
                        myContext.fillText(myLabel, myCentroidX, myCentroidY - 8);
                    }
                }
            }
        }

        function myPostProcessClassification(myOutputTensor) {
            const myNumClasses = myCurrentConfig.myClassLabels.length;

            if (myOutputTensor.shape[1] !== myNumClasses) { 
                 myStatusElement.textContent = `ERROR: Model output (${myOutputTensor.shape[1]}) != Label count (${myNumClasses})`; 
                 return;
            }

            const myResult = myOutputTensor.squeeze().arraySync();

            let myMaxProbability = 0;
            let myMaxClassIndex = 0;

            for (let i = 0; i < myResult.length; i++) {
                if (myResult[i] > myMaxProbability) {
                    myMaxProbability = myResult[i];
                    myMaxClassIndex = i;
                }
            }

            const myLabel = myCurrentConfig.myClassLabels[myMaxClassIndex];
            const myConfidence = (myMaxProbability * 100).toFixed(2);

            document.getElementById('myResultLabel').textContent = myLabel.toUpperCase();
            document.getElementById('myResultConfidence').textContent = `${myConfidence}% Confidence`;

            console.log(`Classified: ${myLabel} (${myConfidence}%)`);
        }

        function myStopAll() {
            myStopWebcam();

            myContext.clearRect(0, 0, myCanvas.width, myCanvas.height);
            myContext.fillStyle = '#333';
            myContext.fillRect(0, 0, myCanvas.width, myCanvas.height);

            if (myCurrentConfig.myModelType === 'classification') {
                document.getElementById('myResultLabel').textContent = 'Awaiting Input...';
                document.getElementById('myResultConfidence').textContent = '';
            }

            myStatusElement.textContent = 'Stopped. Click "Start" or load a new model.';
            myStartButton.disabled = false;
            myStopButton.disabled = true;

            console.log('Stopped');
        }

        // =================================================================
        // üè† HTML/DOM SETUP
        // =================================================================
        
        function myCreateDOM() {
            // ... (DOM Creation logic from your original code, adjusted for minimal style) ...
            const myMainContainer = document.createElement('div');
            myMainContainer.id = 'myMainContainer';
            myMainContainer.style.cssText = 'max-width:800px; width:100%; padding:20px; box-shadow:0 0 10px rgba(0,0,0,0.1); margin:20px auto; background:white;'; 

            const myTitle = document.createElement('h1');
            myTitle.textContent = 'LiteRT.js Model Detector';
            myMainContainer.appendChild(myTitle);

            const myInstructions = document.createElement('div');
            myInstructions.id = 'myInstructions';
            myInstructions.innerHTML = 'Load models via URL, File, or Drag & Drop';
            myMainContainer.appendChild(myInstructions);

            // Model Select Dropdown
            myModelSelect = document.createElement('select');
            myModelSelect.style.cssText = 'width:100%; padding:10px; margin-bottom:15px;';
            myModelSelect.innerHTML = '<option value="">Loading models from GitHub...</option>';
            myModelSelect.onchange = myHandleModelSelect;
            myMainContainer.appendChild(myModelSelect);

            // URL Upload
            const myUrlGroup = document.createElement('div');
            myUrlGroup.style.cssText = 'display:flex; gap:5px; margin-bottom:10px;';
            myUrlInput = document.createElement('input');
            myUrlInput.type = 'text';
            myUrlInput.placeholder = 'Paste Model URL (.tflite or .lite)';
            myUrlInput.value = myDefaultConfig.myDefaultUrl;
            myUrlInput.style.flexGrow = '1';
            myUrlGroup.appendChild(myUrlInput);
            const myUrlButton = document.createElement('button');
            myUrlButton.textContent = 'Load from URL';
            myUrlButton.onclick = () => myLoadModelFromUrl(myUrlInput.value);
            myUrlGroup.appendChild(myUrlButton);
            myMainContainer.appendChild(myUrlGroup);

            // File Input
            myFileInput = document.createElement('input');
            myFileInput.type = 'file';
            myFileInput.style.marginBottom = '15px';
            myFileInput.setAttribute('accept', '.tflite,.lite');
            myFileInput.onchange = myHandleFileInput;
            myMainContainer.appendChild(myFileInput);

            // Model info display
            myModelInfo = document.createElement('div');
            myModelInfo.id = 'myModelInfo';
            myModelInfo.style.cssText = 'text-align:center; padding:10px; margin-top:10px; border:1px solid #ccc; font-size:0.9em;';
            myModelInfo.innerHTML = `
                <span style="font-weight:bold;">Model:</span>
                <span id="myModelName">No model loaded</span> | 
                <span style="font-weight:bold;">Type:</span>
                <span id="myModelType">Unknown</span> | 
                <span style="font-weight:bold;">Size:</span>
                <span id="myModelSize">N/A</span> |
                <span style="font-weight:bold;">Config:</span>
                <span id="myModelConfig">N/A</span>
            `;
            myMainContainer.appendChild(myModelInfo);

            // Labels Textarea
            const myLabelHeader = document.createElement('div');
            myLabelHeader.style.cssText = 'font-size:0.9em; margin-top:15px; margin-bottom:5px; font-weight:bold;';
            myLabelHeader.textContent = 'Class Labels (Comma-separated)';
            myMainContainer.appendChild(myLabelHeader);                        
            myLabelEditor = document.createElement('textarea');
            myLabelEditor.id = 'myLabelEditor';
            myLabelEditor.placeholder = 'Enter labels here (e.g., background, pen)';
            myLabelEditor.oninput = myUpdateConfigFromLabels;
            myLabelEditor.style.cssText = 'width:100%; height:80px; padding:10px; box-sizing:border-box; margin-bottom:15px;';
            myMainContainer.appendChild(myLabelEditor);

            // Control section
            const myControlSection = document.createElement('div');
            myControlSection.style.cssText = 'text-align:center; margin-bottom:20px;';
                        
            myStatusElement = document.createElement('div');
            myStatusElement.id = 'myStatusMessage';
            myStatusElement.textContent = 'Click "Start" to begin';
            myStatusElement.style.cssText = 'padding:10px; margin:10px 0; border:1px solid gray; background-color:lightgray; font-weight:bold;';
            myControlSection.appendChild(myStatusElement);

            myStartButton = document.createElement('button');
            myStartButton.textContent = 'Start Webcam & Load Default Model';
            myStartButton.onclick = myStartAll;
            myStartButton.id = 'myStartButton';
            myControlSection.appendChild(myStartButton);

            myStopButton = document.createElement('button');
            myStopButton.textContent = 'Stop Webcam';
            myStopButton.onclick = myStopAll;
            myStopButton.disabled = true;
            myControlSection.appendChild(myStopButton);
            myMainContainer.appendChild(myControlSection);

            // Hidden video element
            myVideoElement = document.createElement('video');
            myVideoElement.id = 'myVideo';
            myVideoElement.setAttribute('playsinline', '');
            myVideoElement.setAttribute('autoplay', '');
            myVideoElement.style.display = 'none';
            myMainContainer.appendChild(myVideoElement);

            // Canvas container with drop overlay
            const myCanvasContainer = document.createElement('div');
            myCanvasContainer.style.cssText = 'position:relative; text-align:center; margin-top:20px;';

            myCanvas = document.createElement('canvas');
            myCanvas.id = 'myCanvas';
            myCanvas.width = myCurrentConfig.myInputResolution;
            myCanvas.height = myCurrentConfig.myInputResolution;
            myContext = myCanvas.getContext('2d');
            myCanvas.style.cssText = 'border:3px solid black; background-color:#333; width:100%; max-width:600px; aspect-ratio:1/1; display:block; margin:0 auto;';
            myCanvasContainer.appendChild(myCanvas);

            myDropOverlay = document.createElement('div');
            myDropOverlay.id = 'myDropOverlay';
            myDropOverlay.style.cssText = 'position:absolute; top:0; left:50%; transform:translateX(-50%); width:100%; max-width:600px; height:100%; border:4px dashed gray; border-radius:8px; display:none; justify-content:center; align-items:center; pointer-events:none;';
            const myDropText = document.createElement('div');
            myDropText.textContent = 'Drop .tflite or .lite file here';
            myDropText.style.cssText = 'font-size:1.5em; font-weight:bold; color:gray; background-color:white; padding:10px; border-radius:8px;';
            myDropOverlay.appendChild(myDropText);
            myCanvasContainer.appendChild(myDropOverlay);
            myMainContainer.appendChild(myCanvasContainer);

            // Classification Result Display
            myResultDisplay = document.createElement('div');
            myResultDisplay.id = 'myResultDisplay';
            myResultDisplay.innerHTML = '<span style="font-size:1.2em;">Classification Result:</span><br><span id="myResultLabel" style="font-size:1.8em; font-weight:bold;">Awaiting Input...</span><span id="myResultConfidence"></span>';
            myResultDisplay.style.cssText = 'margin-top:20px; padding:15px; border-radius:8px; background-color:lightgreen; border:2px solid green; text-align:center; display:none;';
            myMainContainer.appendChild(myResultDisplay);

            document.body.appendChild(myMainContainer);
            mySetupDragAndDrop();
            myUpdateLabelEditor();
            myLoadGithubModels();
        }

        window.onload = myCreateDOM;
    </script>
</head>
<body>
    </body>
</html>
