<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>myExternalFOMODetector</title>

    <!-- Minimal, Simple CSS -->
    <style>
        body { 
            font-family: Arial, sans-serif; 
            display: flex; 
            flex-direction: column; 
            align-items: center; 
            margin: 20px; 
            background-color: #f0f0f0; 
        }
        #myContainer { 
            max-width: 480px; 
            width: 100%; 
            background: white; 
            padding: 20px; 
            border-radius: 8px; 
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1); 
            margin-bottom: 20px;
        }
        #myCanvas { 
            border: 2px solid #007bff; 
            border-radius: 4px; 
            margin-top: 20px; 
            background-color: #333; 
            width: 100%; /* Make it responsive */
            height: auto;
            max-width: 400px; /* Limit max size */
            display: block;
        }
        #myVideo { 
            display: none; /* Hidden video to feed the canvas */
        } 
        .myButton { 
            background-color: #007bff; 
            color: white; 
            padding: 10px 15px; 
            border: none; 
            border-radius: 4px; 
            cursor: pointer; 
            font-size: 16px; 
            margin-top: 10px; 
            width: 100%; 
            box-sizing: border-box;
            transition: background-color 0.3s;
        }
        .myButton:hover { 
            background-color: #0056b3; 
        }
        .myButton:disabled { 
            background-color: #ccc; 
            cursor: not-allowed; 
        }
        .myStatus { 
            margin-top: 10px; 
            font-weight: bold; 
            color: #333; 
            text-align: center; 
            padding: 10px; 
            border-radius: 4px; 
            background-color: #e0f7fa;
            border: 1px solid #b2ebf2;
        }
        .myLabel { 
            display: block; 
            margin-top: 15px; 
            margin-bottom: 5px; 
            font-weight: bold; 
        }
        .myInput { 
            width: 100%; 
            padding: 8px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            box-sizing: border-box; 
        }
        .myGroup { 
            border: 1px dashed #bbb; 
            padding: 15px; 
            border-radius: 4px; 
            margin-top: 15px; 
        }
    </style>
    
    <!-- TensorFlow Libraries (External - required for TFLite loading) -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-tflite@0.0.1-alpha.9/dist/tf-tflite.min.js"></script>
</head>
<body>

    <script>
        // =================================================================
        // ðŸš€ USER-CONFIGURABLE MODEL SETTINGS
        // =================================================================
        const myModelConfig = {
            // URL for remote loading (Use a different, known working TFLite model if this one fails consistently)
            myDefaultUrl: 'https://hpssjellis.github.io/my-examples-of-edge-impulse/public/tflite/fomo01.tflite', 
            
            // NOTE: The following parameters MUST match the model you load.
            // If you load a different model, update these values (Input size, grid scale, and class labels).
            myInputResolution: 240, 
            myGridScaleFactor: 8, // 240 / 30 = 8 (Grid size should be InputResolution / GridScaleFactor)
            myConfidenceThreshold: 0.5, 
            myClassLabels: ['background', 'myObjectOne', 'myObjectTwo', 'another_thing'], // Must match the model's classes
            myInputChannels: 3, 
        };

        // =================================================================
        // âš™ï¸ INTERNAL VARIABLES 
        // =================================================================
        let myTfLiteModel = null;
        let myIsWebcamReady = false;
        let myCanvasElement = null;
        let myVideoElement = null;
        let myContext = null;
        let myStatusElement = null;
        let myAnimationFrameId = null;
        
        let myFileInput = null;
        let myUrlInput = null;

        // Derived variables for quick access
        const myInputSize = myModelConfig.myInputResolution;
        const myGridSize = myInputSize / myModelConfig.myGridScaleFactor;

        // =================================================================
        // ðŸ  HTML SETUP (Simple DOM Creation)
        // =================================================================
        
        /**
         * @function myCreateDOM
         * Initializes all necessary DOM elements with minimal styling.
         */
        function myCreateDOM() {
            const myContainer = document.createElement('div');
            myContainer.id = 'myContainer';
            
            // Title
            const myTitle = document.createElement('h1');
            myTitle.style.fontSize = '1.5em';
            myTitle.style.fontWeight = 'bold';
            myTitle.style.marginBottom = '15px';
            myTitle.style.textAlign = 'center';
            myTitle.textContent = 'External FOMO Detector';
            myContainer.appendChild(myTitle);

            // Status Message
            myStatusElement = document.createElement('p');
            myStatusElement.id = 'myStatusMessage';
            myStatusElement.className = 'myStatus';
            myStatusElement.textContent = 'Select a model loading method to start.';
            myContainer.appendChild(myStatusElement);
            
            // --- Controls Group ---
            const myControlsDiv = document.createElement('div');
            myControlsDiv.id = 'myControls';

            // 1. Load from File (Method A)
            const myFileGroup = document.createElement('div');
            myFileGroup.className = 'myGroup';
            myFileGroup.style.borderColor = '#007bff';
            myFileGroup.style.backgroundColor = '#f7faff';

            const myFileLabel = document.createElement('p');
            myFileLabel.style.fontWeight = 'bold';
            myFileLabel.textContent = '1. Load From Computer File (.tflite):';
            myFileGroup.appendChild(myFileLabel);
            
            myFileInput = document.createElement('input'); 
            myFileInput.type = 'file';
            myFileInput.id = 'myFileInput';
            myFileInput.accept = '.tflite';
            myFileInput.style.marginTop = '10px';
            // Use 'onchange' to trigger the load when a file is selected (Immediate activation)
            myFileInput.onchange = myLoadFromFile; 
            myFileGroup.appendChild(myFileInput);
            myControlsDiv.appendChild(myFileGroup);

            // 2. Load from Default URL (Method B)
            const myDefaultUrlButton = document.createElement('button');
            myDefaultUrlButton.className = 'myButton';
            myDefaultUrlButton.textContent = `2. Load Default URL (${myModelConfig.myDefaultUrl.split('/').pop()})`;
            myDefaultUrlButton.onclick = myLoadFromDefaultUrl;
            myControlsDiv.appendChild(myDefaultUrlButton);

            // 3. Load from Custom URL (New Requirement)
            const myUrlGroup = document.createElement('div');
            myUrlGroup.className = 'myGroup';

            const myUrlLabel = document.createElement('p');
            myUrlLabel.style.fontWeight = 'bold';
            myUrlLabel.textContent = '3. Load From Custom URL:';
            myUrlGroup.appendChild(myUrlLabel);

            myUrlInput = document.createElement('input');
            myUrlInput.type = 'text';
            myUrlInput.id = 'myUrlInput';
            myUrlInput.value = myModelConfig.myDefaultUrl; // Set default value
            myUrlInput.placeholder = 'Enter .tflite URL here';
            myUrlInput.className = 'myInput';
            myUrlInput.style.marginTop = '8px';
            myUrlGroup.appendChild(myUrlInput);

            const myCustomUrlButton = document.createElement('button');
            myCustomUrlButton.className = 'myButton';
            myCustomUrlButton.textContent = 'Load Custom URL and Start Webcam';
            myCustomUrlButton.onclick = myLoadFromCustomUrl;
            myUrlGroup.appendChild(myCustomUrlButton);
            
            myControlsDiv.appendChild(myUrlGroup);

            // 4. Reset Button (New)
            const myResetButton = document.createElement('button');
            myResetButton.className = 'myButton';
            myResetButton.textContent = 'Reset / Stop Webcam';
            myResetButton.onclick = myResetApplication;
            myResetButton.style.marginTop = '25px'; 
            myControlsDiv.appendChild(myResetButton);
            
            myContainer.appendChild(myControlsDiv);
            document.body.appendChild(myContainer);


            // Video and Canvas
            myVideoElement = document.createElement('video');
            myVideoElement.id = 'myVideo';
            myVideoElement.setAttribute('playsinline', '');
            myVideoElement.setAttribute('autoplay', '');
            document.body.appendChild(myVideoElement);

            myCanvasElement = document.createElement('canvas');
            myCanvasElement.id = 'myCanvas';
            myCanvasElement.width = myInputSize;
            myCanvasElement.height = myInputSize; 
            document.body.appendChild(myCanvasElement);

            myContext = myCanvasElement.getContext('2d');
        }
        
        window.onload = myCreateDOM; // Create everything on load

        // =================================================================
        // ðŸ’» MODEL LOADING AND STARTUP LOGIC
        // =================================================================
        
        /**
         * @function myGetAllButtons
         * Gets all interactive elements to disable them during loading.
         */
        function myGetAllButtons() {
            // Includes all myButton classes and the file input
            return [
                ...document.querySelectorAll('.myButton'),
                myFileInput,
                myUrlInput
            ];
        }

        /**
         * @function myDisableControls
         * Disables control elements during loading.
         */
        function myDisableControls(myDisabled) {
            myGetAllButtons().forEach(myEl => myEl.disabled = myDisabled);
        }

        /**
         * @function myLoadFromDefaultUrl
         * Wrapper function to load the model from the configured default URL.
         */
        function myLoadFromDefaultUrl() {
            myLoadModelAndStartCamera(myModelConfig.myDefaultUrl);
        }

        /**
         * @function myLoadFromCustomUrl
         * Wrapper function to load the model from the text input URL.
         */
        function myLoadFromCustomUrl() {
            const myCustomUrl = myUrlInput.value.trim();
            if (myCustomUrl) {
                myLoadModelAndStartCamera(myCustomUrl);
            } else {
                myStatusElement.textContent = 'Error: Please enter a valid URL in the custom URL field.';
            }
        }

        /**
         * @function myLoadFromFile
         * Handles the change event from the file input to load a local file.
         * Note: This function now executes immediately on file selection via 'onchange'.
         */
        function myLoadFromFile() {
            const mySelectedFile = myFileInput.files[0];
            if (mySelectedFile) {
                // Pass the File object directly
                myLoadModelAndStartCamera(mySelectedFile);
            } else {
                // If the user clears the selection, re-enable everything
                myDisableControls(false); 
                myStatusElement.textContent = 'Please select a .tflite file first or choose another method.';
            }
        }

        /**
         * @function myLoadModelAndStartCamera
         * Main function to load the model (File or URL) and start the webcam.
         * @param {string|File} mySource - The URL string or the File object.
         */
        async function myLoadModelAndStartCamera(mySource) {
            myStopInferenceLoop(); 
            myDisableControls(true);

            const mySourceType = typeof mySource === 'string' ? 'URL' : 'File';
            const myDisplayPath = typeof mySource === 'string' ? mySource : mySource.name;
            
            myStatusElement.textContent = `Loading model from ${mySourceType}: ${myDisplayPath}...`;
            
            let myModelSource = mySource; // Default to direct source

            try {
                if (mySourceType === 'File') {
                    // Reverting to the user's known working method: load file into ArrayBuffer first
                    myModelSource = await new Promise((myResolve, myReject) => {
                        const myReader = new FileReader();
                        myReader.onload = () => myResolve(myReader.result);
                        myReader.onerror = myReject;
                        myReader.readAsArrayBuffer(mySource);
                    });
                    myStatusElement.textContent = `File read into buffer. Loading model from ${myDisplayPath}...`;
                }

                // tflite.loadTFLiteModel accepts either a URL string or an ArrayBuffer
                myTfLiteModel = await tflite.loadTFLiteModel(myModelSource);
                
                myStatusElement.textContent = 'Model loaded successfully! Starting webcam...';
                console.log(`TFLite Model Loaded from ${mySourceType}:`, myDisplayPath);

                // Start the webcam
                await mySetupWebcam();

            } catch (myError) {
                myStatusElement.textContent = `Failed to load model from ${mySourceType}. Check the console (F12) for details.`;
                console.error('Model loading error:', myError);
                
                myDisableControls(false);
            }
        }

        /**
         * @function mySetupWebcam
         * Initializes the webcam stream.
         */
        async function mySetupWebcam() {
            if (myIsWebcamReady) return;

            try {
                const myStream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        width: myInputSize,
                        height: myInputSize,
                        facingMode: 'user'
                    },
                    audio: false
                });

                myVideoElement.srcObject = myStream;
                await new Promise(myResolve => myVideoElement.onloadedmetadata = myResolve); 

                myVideoElement.play();
                myIsWebcamReady = true;
                myStatusElement.textContent = 'Webcam active. Running inference... (Look for squares on the canvas)';
                myDisableControls(false); // Re-enable controls once running

                myRunInferenceLoop();

            } catch (myError) {
                myStatusElement.textContent = `Error accessing webcam: ${myError.message}.`;
                console.error('Webcam access error:', myError);
                myDisableControls(false);
            }
        }

        /**
         * @function myRunInferenceLoop
         * The main loop for frame capture and model inference.
         */
        function myRunInferenceLoop() {
            tf.tidy(() => {
                if (!myTfLiteModel || !myIsWebcamReady) {
                    return;
                }

                // 1. Capture and Preprocess Frame
                myContext.drawImage(myVideoElement, 0, 0, myInputSize, myInputSize);
                let myInputTensor = tf.browser.fromPixels(myCanvasElement, myModelConfig.myInputChannels);

                // Normalize and add batch dimension [1, H, W, C]
                let myNormalizedTensor = myInputTensor
                    .resizeBilinear([myInputSize, myInputSize])
                    .cast('float32')
                    .div(255.0)
                    .expandDims(0); 

                // 2. Run Inference
                const myOutputTensor = myTfLiteModel.predict(myNormalizedTensor);

                // 3. Post-processing (FOMO-specific)
                myPostProcessFomo(myOutputTensor);
            }); 

            myAnimationFrameId = requestAnimationFrame(myRunInferenceLoop);
        }
        
        /**
         * @function myPostProcessFomo
         * Interprets the FOMO output tensor to draw bounding boxes.
         */
        function myPostProcessFomo(myOutputTensor) {
            const myPredictionData = myOutputTensor.dataSync();
            const myOutputShape = myOutputTensor.shape;
            const myNumClasses = myOutputShape[3]; 
            const myGridX = myOutputShape[1];
            const myGridY = myOutputShape[2];

            // Diagnostic: Log the actual model output shape, which should be [1, 30, 30, X] for FOMO
            console.log("Model Output Shape:", myOutputShape); 

            if (myGridX !== myGridSize || myGridY !== myGridSize) {
                console.error("Model output shape mismatch. Expected grid size:", myGridSize, "Actual grid size:", myGridX, "x", myGridY);
                return;
            }

            // Redraw the video frame (important for continuous stream)
            myContext.drawImage(myVideoElement, 0, 0, myInputSize, myInputSize); 

            // Iterate over the prediction grid (i=row, j=column)
            for (let i = 0; i < myGridSize; i++) {
                for (let j = 0; j < myGridSize; j++) {
                    const myCellStartIndex = (i * myGridSize * myNumClasses) + (j * myNumClasses);

                    let myMaxProbability = 0;
                    let myMaxClassIndex = 0;

                    // Find the highest probability class
                    for (let k = 0; k < myNumClasses; k++) {
                        const myProbability = myPredictionData[myCellStartIndex + k];
                        if (myProbability > myMaxProbability) {
                            myMaxProbability = myProbability;
                            myMaxClassIndex = k;
                        }
                    }

                    // Check: Not background class (index 0) AND meets confidence threshold
                    if (myMaxClassIndex !== 0 && myMaxProbability >= myModelConfig.myConfidenceThreshold) {
                        
                        // Calculate the centroid coordinates in the final canvas space (scaled up)
                        const myCentroidX = (j * myModelConfig.myGridScaleFactor) + (myModelConfig.myGridScaleFactor / 2);
                        const myCentroidY = (i * myModelConfig.myGridScaleFactor) + (myModelConfig.myGridScaleFactor / 2);
                        
                        const myLabel = myModelConfig.myClassLabels[myMaxClassIndex];
                        
                        // Draw the visualization
                        // Use a simple, high-contrast color scheme
                        myContext.fillStyle = myMaxClassIndex === 1 ? 'rgba(255, 69, 0, 0.8)' : 'rgba(50, 205, 50, 0.8)'; // Red-Orange or Lime Green
                        myContext.fillRect(myCentroidX - 4, myCentroidY - 4, 8, 8); // Draw a small square at the centroid
                        
                        myContext.font = '10px Arial';
                        myContext.fillStyle = 'white'; 
                        myContext.textAlign = 'center';
                        myContext.fillText(myLabel, myCentroidX, myCentroidY - 6);
                    }
                }
            }
        }
        
        /**
         * @function myResetApplication
         * Stops webcam, clears model reference, resets status, and re-enables controls.
         */
        function myResetApplication() {
            myStopInferenceLoop();
            myTfLiteModel = null;
            
            // Clear the canvas and redraw the background
            if (myContext && myCanvasElement) {
                myContext.clearRect(0, 0, myInputSize, myInputSize);
                myContext.fillStyle = '#333'; // Match the original canvas background color
                myContext.fillRect(0, 0, myInputSize, myInputSize);
            }
            
            myStatusElement.textContent = 'Application Reset. Select a model loading method to start.';
            myDisableControls(false); // Re-enable all buttons and inputs
            console.log('Application reset.');
        }

        /**
         * @function myStopInferenceLoop
         * Stops the continuous frame request loop and releases webcam.
         */
        function myStopInferenceLoop() {
            if (myAnimationFrameId) {
                cancelAnimationFrame(myAnimationFrameId);
                myAnimationFrameId = null;
            }
            if (myVideoElement && myVideoElement.srcObject) {
                // Stops all tracks on the stream
                myVideoElement.srcObject.getTracks().forEach(track => track.stop());
                myVideoElement.srcObject = null;
            }
            myIsWebcamReady = false;
        }
    </script>
</body>
</html>
